{
    "docs": [
        {
            "location": "/", 
            "text": "ProtonType\n\n\nUm simples web framework feito em TypeScript.\n\n\nO ProtonType tem como objetivo tornar simples e agrad\u00e1vel o desensolvimento de APIs REST e cria\u00e7\u00e3o de modelos de banco de dados. Utilizando \nExpress\n e \nSequelize ORM\n ajuda na cria\u00e7\u00e3o de aplica\u00e7\u00f5es web robustas.\n\n\nInstala\u00e7\u00e3o\n\n\nnpm install protontype --save\n\n\n\n\n\nCria\u00e7\u00e3o de Models\n\n\nCriar um arquivo ParticlesModel.ts\n\n\nimport\n \n{\n \nBaseModel\n,\n \nSequelizeBaseModelAttr\n,\n \nModel\n,\n \nDataTypes\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nModel\n({\n\n    \nname\n:\n \nParticles\n,\n\n    \ndefinition\n:\n \n{\n\n        \nname\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nSTRING\n\n        \n},\n\n        \nsymbol\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nSTRING\n\n        \n},\n\n        \nmass\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nBIGINT\n\n        \n}\n\n\n    \n}\n\n\n})\n\n\nexport\n \nclass\n \nParticlesModel\n \nextends\n \nBaseModel\nParticle\n \n{\n\n\n\n}\n\n\n\nexport\n \ninterface\n \nParticle\n \nextends\n \nSequelizeBaseModelAttr\n \n{\n\n    \nname\n:\n \nstring\n;\n\n    \nsymbol\n:\n \nstring\n;\n\n    \nmass\n:\n \nnumber\n;\n\n\n}\n\n\n\n\n\n\nCria\u00e7\u00e3o de Routers\n\n\nCriar arquivo ParticlesRouter.ts\n\n\nimport\n \n{\n \nParticlesModel\n \n}\n \nfrom\n \n./ParticlesModel\n;\n\n\nimport\n \n{\n \nBaseCrudRouter\n,\n \nRouterClass\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/particles\n,\n\n    \nmodelInstances\n:\n \n[\nnew\n \nParticlesModel\n()]\n\n\n})\n\n\nexport\n \nclass\n \nParticlesRouter\n \nextends\n \nBaseCrudRouter\n \n{\n\n\n\n}\n\n\n\n\n\n\nCria\u00e7\u00e3o de Middlewares\n\n\nimport\n \n{\n \nMiddleware\n,\n \nMiddlewareFunctionParams\n \n}\n \nfrom\n \n./../decorators/MiddlewareConfig\n;\n\n\nimport\n \n{\n \nProtonMiddleware\n \n}\n \nfrom\n \n./ProtonMiddleware\n;\n\n\nimport\n \n*\n \nas\n \nbodyParser\n \nfrom\n \nbody-parser\n;\n\n\n\nexport\n \nclass\n \nJsonContentMiddleware\n \nextends\n \nProtonMiddleware\n \n{\n\n\n    \n@\nMiddleware\n()\n\n    \njsonContentMiddlewareFunc\n(\nparams\n:\n \nMiddlewareFunctionParams\n)\n \n{\n\n        \nparams\n.\napp\n.\ngetExpress\n().\nset\n(\njson spaces\n,\n \n2\n);\n\n        \nparams\n.\napp\n.\ngetExpress\n().\nuse\n(\nbodyParser\n.\njson\n());\n\n        \nparams\n.\nnext\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nBootstrap\n\n\nimport\n \n{\n \nParticlesRouter\n \n}\n \nfrom\n \n./ParticlesRouter\n;\n\n\nimport\n \n{\n \nProtonApplication\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\nnew\n \nProtonApplication\n()\n\n    \n.\naddRouter\n(\nnew\n \nParticlesRouter\n())\n\n    \n.\nbootstrap\n();", 
            "title": "Home"
        }, 
        {
            "location": "/#protontype", 
            "text": "Um simples web framework feito em TypeScript.  O ProtonType tem como objetivo tornar simples e agrad\u00e1vel o desensolvimento de APIs REST e cria\u00e7\u00e3o de modelos de banco de dados. Utilizando  Express  e  Sequelize ORM  ajuda na cria\u00e7\u00e3o de aplica\u00e7\u00f5es web robustas.", 
            "title": "ProtonType"
        }, 
        {
            "location": "/#instalacao", 
            "text": "npm install protontype --save", 
            "title": "Instala\u00e7\u00e3o"
        }, 
        {
            "location": "/#criacao-de-models", 
            "text": "Criar um arquivo ParticlesModel.ts  import   {   BaseModel ,   SequelizeBaseModelAttr ,   Model ,   DataTypes   }   from   protontype ;  @ Model ({ \n     name :   Particles , \n     definition :   { \n         name :   { \n             type :   DataTypes . STRING \n         }, \n         symbol :   { \n             type :   DataTypes . STRING \n         }, \n         mass :   { \n             type :   DataTypes . BIGINT \n         } \n\n     }  })  export   class   ParticlesModel   extends   BaseModel Particle   {  }  export   interface   Particle   extends   SequelizeBaseModelAttr   { \n     name :   string ; \n     symbol :   string ; \n     mass :   number ;  }", 
            "title": "Cria\u00e7\u00e3o de Models"
        }, 
        {
            "location": "/#criacao-de-routers", 
            "text": "Criar arquivo ParticlesRouter.ts  import   {   ParticlesModel   }   from   ./ParticlesModel ;  import   {   BaseCrudRouter ,   RouterClass   }   from   protontype ;  @ RouterClass ({ \n     baseUrl :   /particles , \n     modelInstances :   [ new   ParticlesModel ()]  })  export   class   ParticlesRouter   extends   BaseCrudRouter   {  }", 
            "title": "Cria\u00e7\u00e3o de Routers"
        }, 
        {
            "location": "/#criacao-de-middlewares", 
            "text": "import   {   Middleware ,   MiddlewareFunctionParams   }   from   ./../decorators/MiddlewareConfig ;  import   {   ProtonMiddleware   }   from   ./ProtonMiddleware ;  import   *   as   bodyParser   from   body-parser ;  export   class   JsonContentMiddleware   extends   ProtonMiddleware   { \n\n     @ Middleware () \n     jsonContentMiddlewareFunc ( params :   MiddlewareFunctionParams )   { \n         params . app . getExpress (). set ( json spaces ,   2 ); \n         params . app . getExpress (). use ( bodyParser . json ()); \n         params . next (); \n     }  }", 
            "title": "Cria\u00e7\u00e3o de Middlewares"
        }, 
        {
            "location": "/#bootstrap", 
            "text": "import   {   ParticlesRouter   }   from   ./ParticlesRouter ;  import   {   ProtonApplication   }   from   protontype ;  new   ProtonApplication () \n     . addRouter ( new   ParticlesRouter ()) \n     . bootstrap ();", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quick Start - Criando uma API em 5 passos\n\n\nEstrutura de pastas e configura\u00e7\u00f5es iniciais\n\n\n    mkdir proton-quickstart\n    \ncd\n proton-quickstart\n    npm init\n    mkdir src\n    npm install protontype --save\n\n\n\n\n\nCriar o arquivo tsconfig.json na raiz do projeto\n\n\n    \n{\n\n      \ncompilerOptions\n:\n \n{\n\n        \ntarget\n:\n \nes5\n,\n\n        \nmodule\n:\n \ncommonjs\n,\n\n        \nemitDecoratorMetadata\n:\n \ntrue\n,\n\n        \nexperimentalDecorators\n:\n \ntrue\n,\n\n        \noutDir\n:\n \ndist\n\n      \n},\n\n      \nexclude\n:\n \n[\n\n        \nnode_modules\n,\n\n        \ndist\n\n      \n]\n\n    \n}\n\n\n\n\n\n\nModel\n\n\nCriar um arquivo ParticlesModel.ts\n\n\n    \nimport\n \n{\n \nBaseModel\n,\n \nSequelizeBaseModelAttr\n,\n \nModel\n,\n \nDataTypes\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \n@\nModel\n({\n\n        \nname\n:\n \nParticles\n,\n\n        \ndefinition\n:\n \n{\n\n            \nname\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nSTRING\n\n            \n},\n\n            \nsymbol\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nSTRING\n\n            \n},\n\n            \nmass\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nBIGINT\n\n            \n}\n\n\n        \n}\n\n    \n})\n\n    \nexport\n \nclass\n \nParticlesModel\n \nextends\n \nBaseModel\nParticle\n \n{\n\n\n    \n}\n\n\n    \nexport\n \ninterface\n \nParticle\n \nextends\n \nSequelizeBaseModelAttr\n \n{\n\n        \nname\n:\n \nstring\n;\n\n        \nsymbol\n:\n \nstring\n;\n\n        \nmass\n:\n \nnumber\n;\n\n    \n}\n\n\n\n\n\n\nRouter\n\n\nCriar arquivo ParticlesRouter.ts\n\n\n    \nimport\n \n{\n \nParticlesModel\n \n}\n \nfrom\n \n./ParticlesModel\n;\n\n    \nimport\n \n{\n \nBaseCrudRouter\n,\n \nRouterClass\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \n@\nRouterClass\n({\n\n        \nbaseUrl\n:\n \n/particles\n,\n\n        \nmodelInstances\n:\n \n[\nnew\n \nParticlesModel\n()]\n\n    \n})\n\n    \nexport\n \nclass\n \nParticlesRouter\n \nextends\n \nBaseCrudRouter\n \n{\n\n\n    \n}\n\n\n\n\n\n\nMain\n\n\nCriar arquivo Main.ts\n\n\n    \nimport\n \n{\n \nParticlesRouter\n \n}\n \nfrom\n \n./ParticlesRouter\n;\n\n    \nimport\n \n{\n \nProtonApplication\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \nnew\n \nProtonApplication\n()\n\n        \n.\naddRouter\n(\nnew\n \nParticlesRouter\n())\n\n        \n.\nbootstrap\n();\n\n\n\n\n\n\nCompilando e Rodando Aplica\u00e7\u00e3o\n\n\n    tsc\n    node dist/Main.ts\n\n\n\n\n\nTestando a API\n\n\nPor padr\u00e3o, a aplica\u00e7\u00e3o usar\u00e1 um banco de dados sqlite. \nSer\u00e1 criado um arquivo proton.sqlite na raiz do projeto.\n\n\nOs endpoints abaixo j\u00e1 estar\u00e3o dispon\u00edveis:\n\n\n\n\nGET /particles\n - Lista todos os registos da tabela Particles\n\n\nPOST /particles\n - Cria um registro na tabela Particles\n\n\nGET /particles/:id\n - Consulta um registro da tabela Particles\n\n\nPUT /particles/:id\n - Atualiza um registro da tabela Particles\n\n\nDELETE /particles/:id\n - Remove um registro da tabela Particles\n\n\n\n\nPodera testar atrav\u00e9s do app \nPostman\n ou outro da sua prefer\u00eancia.\n\n\nC\u00f3digo completo do quick start\n\n\nhttps://github.com/linck/proton-quickstart", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quickstart/#quick-start-criando-uma-api-em-5-passos", 
            "text": "", 
            "title": "Quick Start - Criando uma API em 5 passos"
        }, 
        {
            "location": "/quickstart/#estrutura-de-pastas-e-configuracoes-iniciais", 
            "text": "mkdir proton-quickstart\n     cd  proton-quickstart\n    npm init\n    mkdir src\n    npm install protontype --save  Criar o arquivo tsconfig.json na raiz do projeto       { \n       compilerOptions :   { \n         target :   es5 , \n         module :   commonjs , \n         emitDecoratorMetadata :   true , \n         experimentalDecorators :   true , \n         outDir :   dist \n       }, \n       exclude :   [ \n         node_modules , \n         dist \n       ] \n     }", 
            "title": "Estrutura de pastas e configura\u00e7\u00f5es iniciais"
        }, 
        {
            "location": "/quickstart/#model", 
            "text": "Criar um arquivo ParticlesModel.ts       import   {   BaseModel ,   SequelizeBaseModelAttr ,   Model ,   DataTypes   }   from   protontype ; \n\n     @ Model ({ \n         name :   Particles , \n         definition :   { \n             name :   { \n                 type :   DataTypes . STRING \n             }, \n             symbol :   { \n                 type :   DataTypes . STRING \n             }, \n             mass :   { \n                 type :   DataTypes . BIGINT \n             } \n\n         } \n     }) \n     export   class   ParticlesModel   extends   BaseModel Particle   { \n\n     } \n\n     export   interface   Particle   extends   SequelizeBaseModelAttr   { \n         name :   string ; \n         symbol :   string ; \n         mass :   number ; \n     }", 
            "title": "Model"
        }, 
        {
            "location": "/quickstart/#router", 
            "text": "Criar arquivo ParticlesRouter.ts       import   {   ParticlesModel   }   from   ./ParticlesModel ; \n     import   {   BaseCrudRouter ,   RouterClass   }   from   protontype ; \n\n     @ RouterClass ({ \n         baseUrl :   /particles , \n         modelInstances :   [ new   ParticlesModel ()] \n     }) \n     export   class   ParticlesRouter   extends   BaseCrudRouter   { \n\n     }", 
            "title": "Router"
        }, 
        {
            "location": "/quickstart/#main", 
            "text": "Criar arquivo Main.ts       import   {   ParticlesRouter   }   from   ./ParticlesRouter ; \n     import   {   ProtonApplication   }   from   protontype ; \n\n     new   ProtonApplication () \n         . addRouter ( new   ParticlesRouter ()) \n         . bootstrap ();   Compilando e Rodando Aplica\u00e7\u00e3o      tsc\n    node dist/Main.ts", 
            "title": "Main"
        }, 
        {
            "location": "/quickstart/#testando-a-api", 
            "text": "Por padr\u00e3o, a aplica\u00e7\u00e3o usar\u00e1 um banco de dados sqlite. \nSer\u00e1 criado um arquivo proton.sqlite na raiz do projeto.  Os endpoints abaixo j\u00e1 estar\u00e3o dispon\u00edveis:   GET /particles  - Lista todos os registos da tabela Particles  POST /particles  - Cria um registro na tabela Particles  GET /particles/:id  - Consulta um registro da tabela Particles  PUT /particles/:id  - Atualiza um registro da tabela Particles  DELETE /particles/:id  - Remove um registro da tabela Particles   Podera testar atrav\u00e9s do app  Postman  ou outro da sua prefer\u00eancia.  C\u00f3digo completo do quick start  https://github.com/linck/proton-quickstart", 
            "title": "Testando a API"
        }, 
        {
            "location": "/router/", 
            "text": "Router\n\n\nA API do Protontype disponibiliza a classe \nExpressRouter\n para ser base dos routers.\n\n\nCriando um Router\n\n\nPara criar uma classe router basta estender a classe \nExpressRouter\n\n\nimport\n \n{\n \nExpressRouter\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\nexport\n \nclass\n \nTasksRouter\n \nextends\n \nExpressRouter\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\nPara configurar uma classe Router deve-se usar o decorator \n@RouterClass()\n\n\nimport\n \n{\n \nExpressRouter\n,\n \nRouterClass\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmodelInstances\n:\n \n[\n \nnew\n \nTaskModel\n(),\n \nnew\n \nOtherModel\n()\n \n],\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyMiddleware\n(),\n \nnew\n \nOtherMiddleware\n()\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nTasksRouter\n \nextends\n \nExpressRouter\n \n{\n\n        \n...\n\n\n}\n\n\n\n\n\n\nUma classe Router poder\u00e3o conter n fun\u00e7es de rotas, chamadas \nRouter Functions\n. Para definir e configurar uma \nrouter function\n deve-se usar o decorator \n@Route()\n. Uma \nRouter Function\n recebe como par\u00e2metro um objeto do tipo \nRouterFunctionParams\n\n\nimport\n \n{\n \nExpressRouter\n,\n \nRouterFunctionParams\n,\n \nMethod\n,\n \nRoute\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmodelInstances\n:\n \n[\n \nnew\n \nTaskModel\n(),\n \nnew\n \nOtherModel\n()\n \n],\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyMiddleware\n(),\n \nnew\n \nOtherMiddleware\n()\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nTasksRouter\n \nextends\n \nExpressRouter\n \n{\n\n\n    \n@\nRoute\n({\n\n        \nendpoint\n:\n \n/\n,\n\n        \nmethod\n:\n \nMethod\n.\nGET\n\n    \n})\n\n    \nlistTasks\n(\nparams\n:\n \nRouterFunctionParams\n)\n \n{\n\n        \nparams\n.\nres\n.\nsend\n({\nid\n:\n \n1\n,\n \ntitle\n:\n \nTask de teste\n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\n@RouterClass()\n\n\nUsado para definir uma classe que cont\u00e9m rotas. Todas classes do tipo \nExpressRouter\n suportam esta anota\u00e7\u00e3o.\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmodelInstances\n:\n \n[\n \nnew\n \nTaskModel\n(),\n \nnew\n \nOtherModel\n()\n \n],\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyRouterMiddleware\n(),\n \nnew\n \nOtherRouterMiddleware\n()\n \n]\n\n\n})\n\n\n\n\n\n\nPropriedades:\n\n\n\n\nbaseUrl\n: Url base do roteador. Todas rodas ser\u00e3o criadas no padr\u00e3o \nbaseUrl + endpoint\n\n\nmodelInstances\n: Inst\u00e2ncias dos Models que o router ira usar. Suportam classes anotadas com \n@Model()\n\n\nmiddlewares\n: Middlewares que atuar\u00e3o para todas as rotas definidas neste router\n\n\n\n\n@Route()\n\n\nUsado para definir e configurar as rotas dentro de um router.\n\n\n@\nRoute\n({\n\n    \nendpoint\n:\n \n/list\n,\n\n    \nmethod\n:\n \nMethod\n.\nGET\n,\n\n    \nmodelName\n:\n \nTask\n,\n\n    \nuseAuth\n:\n \ntrue\n,\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyRouteMiddleware\n(),\n \nnew\n \nOtherRouteMiddleware\n()\n \n]\n\n\n})\n\n\n\n\n\n\nPropriedades:\n\n\n\n\nendpoint\n: Define o endpoint da rota. A url desta rota ser\u00e1 formada pela \nbaseUrl\n (definida na \n@RouterClass\n) + \nendpoint\n. Exemplo: \nhttp://locathost/tasks/list\n\n\nmethod\n: Verbo HTTP usado para esta rota. GET, POST, DELETE...\n\n\nmodelName\n: Nome do model que sera injetado no par\u00e2metro \nmodel\n de \nRouterFunctionParams\n\n\nuseAuth\n: Indica se esta rota ser\u00e1 autenticada por algum middleware de autentica\u00e7\u00e3o (\nAuthMiddleware\n)\n\n\nmiddlewares\n: Middlewares que atuar\u00e3o somente para esta rota especifica\n\n\n\n\nRouterFunctionParams\n\n\nToda \nRouter Function\n deve ter como par\u00e2metros um objeto do tipo \nRouterFunctionParams\n\n\n@\nRoute\n({\n\n    \nendpoint\n:\n \n/\n,\n\n    \nmethod\n:\n \nMethod\n.\nGET\n\n\n})\n\n\nlistTasks\n(\nparams\n:\n \nRouterFunctionParams\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nparams\n.\nreq\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\nres\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\nmodel\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\napp\n);\n\n\n}\n\n\n\n\n\n\nPropriedades:\n\n\n\n\nreq\n: Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do \nExpress\n.\n\n\nres\n: Objeto usado para enviar a resposta http. Corresponde ao objeto de response do \nExpress\n.\n\n\nmodel\n: Inst\u00e2ncia do model especificado em \nmodelName\n de \n@Route\n\n\napp\n: Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.", 
            "title": "Routers"
        }, 
        {
            "location": "/router/#router", 
            "text": "A API do Protontype disponibiliza a classe  ExpressRouter  para ser base dos routers.", 
            "title": "Router"
        }, 
        {
            "location": "/router/#criando-um-router", 
            "text": "Para criar uma classe router basta estender a classe  ExpressRouter  import   {   ExpressRouter   }   from   protontype ;  export   class   TasksRouter   extends   ExpressRouter   { \n     ...  }   Para configurar uma classe Router deve-se usar o decorator  @RouterClass()  import   {   ExpressRouter ,   RouterClass   }   from   protontype ;  @ RouterClass ({ \n     baseUrl :   /tasks , \n     modelInstances :   [   new   TaskModel (),   new   OtherModel ()   ], \n     middlewares :   [   new   MyMiddleware (),   new   OtherMiddleware ()   ]  })  export   class   TasksRouter   extends   ExpressRouter   { \n         ...  }   Uma classe Router poder\u00e3o conter n fun\u00e7es de rotas, chamadas  Router Functions . Para definir e configurar uma  router function  deve-se usar o decorator  @Route() . Uma  Router Function  recebe como par\u00e2metro um objeto do tipo  RouterFunctionParams  import   {   ExpressRouter ,   RouterFunctionParams ,   Method ,   Route   }   from   protontype ;  @ RouterClass ({ \n     baseUrl :   /tasks , \n     modelInstances :   [   new   TaskModel (),   new   OtherModel ()   ], \n     middlewares :   [   new   MyMiddleware (),   new   OtherMiddleware ()   ]  })  export   class   TasksRouter   extends   ExpressRouter   { \n\n     @ Route ({ \n         endpoint :   / , \n         method :   Method . GET \n     }) \n     listTasks ( params :   RouterFunctionParams )   { \n         params . res . send ({ id :   1 ,   title :   Task de teste }); \n     }  }", 
            "title": "Criando um Router"
        }, 
        {
            "location": "/router/#routerclass", 
            "text": "Usado para definir uma classe que cont\u00e9m rotas. Todas classes do tipo  ExpressRouter  suportam esta anota\u00e7\u00e3o.  @ RouterClass ({ \n     baseUrl :   /tasks , \n     modelInstances :   [   new   TaskModel (),   new   OtherModel ()   ], \n     middlewares :   [   new   MyRouterMiddleware (),   new   OtherRouterMiddleware ()   ]  })   Propriedades:   baseUrl : Url base do roteador. Todas rodas ser\u00e3o criadas no padr\u00e3o  baseUrl + endpoint  modelInstances : Inst\u00e2ncias dos Models que o router ira usar. Suportam classes anotadas com  @Model()  middlewares : Middlewares que atuar\u00e3o para todas as rotas definidas neste router", 
            "title": "@RouterClass()"
        }, 
        {
            "location": "/router/#route", 
            "text": "Usado para definir e configurar as rotas dentro de um router.  @ Route ({ \n     endpoint :   /list , \n     method :   Method . GET , \n     modelName :   Task , \n     useAuth :   true , \n     middlewares :   [   new   MyRouteMiddleware (),   new   OtherRouteMiddleware ()   ]  })   Propriedades:   endpoint : Define o endpoint da rota. A url desta rota ser\u00e1 formada pela  baseUrl  (definida na  @RouterClass ) +  endpoint . Exemplo:  http://locathost/tasks/list  method : Verbo HTTP usado para esta rota. GET, POST, DELETE...  modelName : Nome do model que sera injetado no par\u00e2metro  model  de  RouterFunctionParams  useAuth : Indica se esta rota ser\u00e1 autenticada por algum middleware de autentica\u00e7\u00e3o ( AuthMiddleware )  middlewares : Middlewares que atuar\u00e3o somente para esta rota especifica", 
            "title": "@Route()"
        }, 
        {
            "location": "/router/#routerfunctionparams", 
            "text": "Toda  Router Function  deve ter como par\u00e2metros um objeto do tipo  RouterFunctionParams  @ Route ({ \n     endpoint :   / , \n     method :   Method . GET  })  listTasks ( params :   RouterFunctionParams )   { \n     console . log ( params . req ); \n     console . log ( params . res ); \n     console . log ( params . model ); \n     console . log ( params . app );  }   Propriedades:   req : Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do  Express .  res : Objeto usado para enviar a resposta http. Corresponde ao objeto de response do  Express .  model : Inst\u00e2ncia do model especificado em  modelName  de  @Route  app : Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.", 
            "title": "RouterFunctionParams"
        }, 
        {
            "location": "/middlewares/", 
            "text": "Middlewares\n\n\nCriando Middlewares\n\n\nPra criar uma classe middleware base estender \nProtonMiddleware\n. Um middleware poder\u00e1 ter um Middleware Function.\n\n\nExemplo:\n\n\nimport\n \n{\n \nMiddleware\n,\n \nMiddlewareFunctionParams\n,\n \nProtonMiddleware\n \n}\n \nfrom\n \nprotontype\n;\n\n\nexport\n \nclass\n \nExampleMiddleware\n \nextends\n \nProtonMiddleware\n \n{\n\n\n    \n@\nMiddleware\n()\n\n    \nexampleMiddlewareFunc\n(\nparams\n:\n \nMiddlewareFunctionParams\n)\n \n{\n\n        \ncosole\n.\nlog\n(\nparams\n.\nreq\n);\n\n        \nconsole\n.\nlog\n(\nparams\n.\nres\n);\n\n        \nparams\n.\nnext\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nMiddleware Function\n\n\nUm \nMiddleware Function\n \u00e9 um m\u00e9todo dentro de uma classe \nProtonMiddleware\n  anotada com o decorator \n@Middleware\n e tem como par\u00e2metro um objeto do tipo \nMiddlewareFunctionParams\n. Este m\u00e9todo define o comportamento do middleware.\n\n\n@\nMiddleware\n()\n\n\nexampleMiddlewareFunc\n(\nparams\n:\n \nMiddlewareFunctionParams\n)\n \n{\n\n    \ncosole\n.\nlog\n(\nparams\n.\nreq\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\nres\n);\n\n    \nparams\n.\nnext\n();\n\n\n}\n\n\n\n\n\n\n@Middleware\n\n\nO decorator \n@Middleware()\n indica qual o m\u00e9todo cont\u00e9m o comportamento do middleware.\n\n\nPropriedades\n\n\n\n\nmodelName: Indica qual o Model ser\u00e1 injetado como par\u00e2metro no \nMiddlewareFunctionParams\n. Opcional\n\n\n\n\nMiddlewareFunctionParams\n\n\nPar\u00e2metros de um \nMiddleware Function\n\n\nPropriedades\n\n\n\n\nreq\n: Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do \nExpress\n.\n\n\nres\n: Objeto usado para enviar a resposta http. Corresponde ao objeto de response do \nExpress\n.\n\n\nnext\n: fun\u00e7\u00e3o usada para chamar o pr\u00f3ximo middleware da cadeia\n\n\nmodel\n: Inst\u00e2ncia do model especificado em \nmodelName\n de \n@Middleware()\n\n\napp\n: Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.\n\n\n\n\nEscopo dos Middlewares\n\n\nOs middlewares podem atuar em diferentes escopos\n\n\nEscopo de Aplica\u00e7\u00e3o\n\n\nEste middleware atuar\u00e1 no escopo da aplica\u00e7\u00e3o, ou seja antes de qualquer rota configurada.\nPara tornar um middleware global, deve-se adicionar ele no bootstrap da aplica\u00e7\u00e3o:\n\n\nnew\n \nProtonApplication\n()\n\n    \n.\naddMiddleware\n(\nnew\n \nExampleMiddleware\n())\n\n    \n.\naddMiddleware\n(\nnew\n \nExampleMiddleware2\n())\n\n    \n.\nbootstrap\n();\n\n\n\n\n\n\nEscopo de Router\n\n\nEste middleware atuar\u00e1 para todas as \nRouter Functions\n dentro de uma classe \nExpressRouter\n.\nPara adicionar middlewares para atuar no escopo do router, este deve ser configurado no decorator \n@RouterClass()\n:\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nExampleMiddleware\n(),\n \nnew\n \nExampleMiddleware2\n()\n \n]\n\n\n})\n\n\n\n\n\n\nEscopo de Rota (Router Function)\n\n\nEste middleware atuar\u00e1 somente para aquela rota espec\u00edfica. Para adicionar middlewares ao escopo da rota, este deve ser configurado no decorator \n@Route()\n:\n\n\n@\nRoute\n({\n\n    \nendpoint\n:\n \n/list\n,\n\n    \nmethod\n:\n \nMethod\n.\nGET\n,\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nExampleMiddleware\n(),\n \nnew\n \nExampleMiddleware2\n()\n \n]\n\n\n})", 
            "title": "Middewares"
        }, 
        {
            "location": "/middlewares/#middlewares", 
            "text": "", 
            "title": "Middlewares"
        }, 
        {
            "location": "/middlewares/#criando-middlewares", 
            "text": "Pra criar uma classe middleware base estender  ProtonMiddleware . Um middleware poder\u00e1 ter um Middleware Function.  Exemplo:  import   {   Middleware ,   MiddlewareFunctionParams ,   ProtonMiddleware   }   from   protontype ;  export   class   ExampleMiddleware   extends   ProtonMiddleware   { \n\n     @ Middleware () \n     exampleMiddlewareFunc ( params :   MiddlewareFunctionParams )   { \n         cosole . log ( params . req ); \n         console . log ( params . res ); \n         params . next (); \n     }  }", 
            "title": "Criando Middlewares"
        }, 
        {
            "location": "/middlewares/#middleware-function", 
            "text": "Um  Middleware Function  \u00e9 um m\u00e9todo dentro de uma classe  ProtonMiddleware   anotada com o decorator  @Middleware  e tem como par\u00e2metro um objeto do tipo  MiddlewareFunctionParams . Este m\u00e9todo define o comportamento do middleware.  @ Middleware ()  exampleMiddlewareFunc ( params :   MiddlewareFunctionParams )   { \n     cosole . log ( params . req ); \n     console . log ( params . res ); \n     params . next ();  }", 
            "title": "Middleware Function"
        }, 
        {
            "location": "/middlewares/#middleware", 
            "text": "O decorator  @Middleware()  indica qual o m\u00e9todo cont\u00e9m o comportamento do middleware.  Propriedades   modelName: Indica qual o Model ser\u00e1 injetado como par\u00e2metro no  MiddlewareFunctionParams . Opcional", 
            "title": "@Middleware"
        }, 
        {
            "location": "/middlewares/#middlewarefunctionparams", 
            "text": "Par\u00e2metros de um  Middleware Function  Propriedades   req : Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do  Express .  res : Objeto usado para enviar a resposta http. Corresponde ao objeto de response do  Express .  next : fun\u00e7\u00e3o usada para chamar o pr\u00f3ximo middleware da cadeia  model : Inst\u00e2ncia do model especificado em  modelName  de  @Middleware()  app : Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.", 
            "title": "MiddlewareFunctionParams"
        }, 
        {
            "location": "/middlewares/#escopo-dos-middlewares", 
            "text": "Os middlewares podem atuar em diferentes escopos", 
            "title": "Escopo dos Middlewares"
        }, 
        {
            "location": "/middlewares/#escopo-de-aplicacao", 
            "text": "Este middleware atuar\u00e1 no escopo da aplica\u00e7\u00e3o, ou seja antes de qualquer rota configurada.\nPara tornar um middleware global, deve-se adicionar ele no bootstrap da aplica\u00e7\u00e3o:  new   ProtonApplication () \n     . addMiddleware ( new   ExampleMiddleware ()) \n     . addMiddleware ( new   ExampleMiddleware2 ()) \n     . bootstrap ();", 
            "title": "Escopo de Aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/middlewares/#escopo-de-router", 
            "text": "Este middleware atuar\u00e1 para todas as  Router Functions  dentro de uma classe  ExpressRouter .\nPara adicionar middlewares para atuar no escopo do router, este deve ser configurado no decorator  @RouterClass() :  @ RouterClass ({ \n     baseUrl :   /tasks , \n     middlewares :   [   new   ExampleMiddleware (),   new   ExampleMiddleware2 ()   ]  })", 
            "title": "Escopo de Router"
        }, 
        {
            "location": "/middlewares/#escopo-de-rota-router-function", 
            "text": "Este middleware atuar\u00e1 somente para aquela rota espec\u00edfica. Para adicionar middlewares ao escopo da rota, este deve ser configurado no decorator  @Route() :  @ Route ({ \n     endpoint :   /list , \n     method :   Method . GET , \n     middlewares :   [   new   ExampleMiddleware (),   new   ExampleMiddleware2 ()   ]  })", 
            "title": "Escopo de Rota (Router Function)"
        }, 
        {
            "location": "/models/", 
            "text": "Models\n\n\nCriando Models\n\n\nO \nProtonType\n usa o \nORM Sequelize\n para cria\u00e7\u00e3o dos Models e acesso ao banco de dados.\n\n\nPara criar um Model, deve-se criar uma classe que \nextends\n de \nBaseModel\n. O\nmapeamento do banco de dados \u00e9 feita a atrav\u00e9s da anota\u00e7\u00e3o @Model que possui os\nseguntes par\u00e2metros:\n\n\n\n\nname\n: Nome do model\n\n\ndefinition\n: Defini\u00e7\u00e3o das colunas. O objeto usado para as defini\u00e7\u00f5es \u00e9 o mesmo de\n    \ndefini\u00e7\u00e3o do\n    Sequelize\n.\n\n\n\n\nExemplo:\n\n\nimport\n \n{\n \nModelNames\n \n}\n \nfrom\n \n./ModelNames\n;\n\n\nimport\n \n{\n \nBaseModel\n,\n \nBelongsTo\n,\n \nDataTypes\n,\n \nModel\n,\n \nSequelizeBaseModelAttr\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nModel\n({\n\n    \nname\n:\n \nModelNames\n.\nTASKS\n,\n\n    \ndefinition\n:\n \n{\n\n        \ntitle\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nSTRING\n,\n\n            \nallowNull\n:\n \nfalse\n,\n\n            \nvalidate\n:\n \n{\n\n                \nnotEmpty\n:\n \ntrue\n\n            \n}\n\n        \n},\n\n        \ndone\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nBOOLEAN\n,\n\n            \nallowNull\n:\n \nfalse\n,\n\n            \ndefaultValue\n:\n \nfalse\n\n        \n}\n\n    \n}\n\n\n})\n\n\nexport\n \nclass\n \nTasksModel\n \nextends\n \nBaseModel\nTask\n \n{\n\n\n\n}\n\n\n\nexport\n \ninterface\n \nTask\n \nextends\n \nSequelizeBaseModelAttr\n \n{\n\n    \ntitle\n:\n \nstring\n;\n\n    \ndone\n:\n \nboolean\n;\n\n    \nuser_id\n:\n \nnumber\n;\n\n\n}\n\n\n\n\n\n\nCarregamento dos Models\n\n\nCada \nBaseModel\n ser\u00e1 carregado automaticamente na hora da sua instancia\u00e7\u00e3o. Geralmente o model sera carregado quando for usado por um \nRouter\n, por\u00e9m o carregamento poder\u00e1 ser for\u00e7ado atrav\u00e9s o \n@LoadModel\n decorator ou simplemente atrav\u00e9s do \nnew\n  \n\n\n@\nLoadModel\n(\nnew\n \nTaskModel\n())\n\n\nexport\n \nclass\n \nUsersModel\n \nextends\n \nBaseModel\nUser\n \n{\n\n\n\n}\n\n\n\n\n\n\nAdicionando relacionamentos e outras configura\u00e7\u00f5es nos Models\n\n\nUm BaseModel permite sobreescrever o m\u00e9todo \nconfigure()\n, que permite acessar a instancia do modelo Sequelize e os modelos j\u00e1 carregados e adicionar l\u00f3gicas e configura\u00e7\u00f5es:\n\n\nexport\n \nclass\n \nUsersModel\n \nextends\n \nBaseModel\nUser\n \n{\n\n    \npublic\n \nconfigure\n()\n:\n \nvoid\n \n{\n\n        \nthis\n.\ngetInstance\n().\nbeforeCreate\n((\nuser\n:\n \nany\n)\n \n=\n \n{\n\n            \nlet\n \nsalt\n:\n \nstring\n \n=\n \nbcrypt\n.\ngenSaltSync\n();\n\n            \nuser\n.\npassword\n \n=\n \nbcrypt\n.\nhashSync\n(\nuser\n.\npassword\n,\n \nsalt\n);\n\n        \n});\n\n\n        \nthis\n.\ngetInstance\n().\nhasMany\n(\nthis\n.\nProtonDB\n.\ngetModel\n(\nTasks\n).\ngetInstance\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsando decorators para criar relacionamentos\n\n\nAlguns decorators est\u00e3os dispon\u00edveis para facilitar a adi\u00e7\u00e3o dos relacionamentos:\n\n\n@\nHasMany\n(\nmodelName\n:\n \nstring\n)\n\n\n@\nHasOne\n(\nmodelName\n:\n \nstring\n)\n\n\n@\nBelongsTo\n(\nmodelName\n:\n \nstring\n)\n\n\n@\nBelongsToMany\n(\nmodelName\n:\n \nstring\n,\n \noptions\n:\n \nSequelize\n.\nAssociationOptionsBelongsToMany\n)\n\n\n\n\n\n\nEstes podem ser usados como nos exemplos abaixo:\n\n\n@\nHasMany\n(\nModelNames\n.\nTASKS\n)\n\n\nexport\n \nclass\n \nUsersModel\n \nextends\n \nBaseModel\nUser\n \n{\n\n    \npublic\n \nconfigure\n()\n:\n \nvoid\n \n{\n\n        \nthis\n.\ngetInstance\n().\nbeforeCreate\n((\nuser\n:\n \nany\n)\n \n=\n \n{\n\n            \nlet\n \nsalt\n:\n \nstring\n \n=\n \nbcrypt\n.\ngenSaltSync\n();\n\n            \nuser\n.\npassword\n \n=\n \nbcrypt\n.\nhashSync\n(\nuser\n.\npassword\n,\n \nsalt\n);\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\n@\nBelongsTo\n(\nModelNames\n.\nUSERS\n)\n\n\nexport\n \nclass\n \nTasksModel\n \nextends\n \nBaseModel\nTask\n \n{\n\n\n}\n\n\n\n\n\n\nPara mais informa\u00e7\u00f5es sobre as possibilidades de configura\u00e7\u00f5es e uso dos Models, consultar a documenta\u00e7\u00e3o do Sequelize: http://docs.sequelizejs.com/en/v3/", 
            "title": "Models"
        }, 
        {
            "location": "/models/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/models/#criando-models", 
            "text": "O  ProtonType  usa o  ORM Sequelize  para cria\u00e7\u00e3o dos Models e acesso ao banco de dados.  Para criar um Model, deve-se criar uma classe que  extends  de  BaseModel . O\nmapeamento do banco de dados \u00e9 feita a atrav\u00e9s da anota\u00e7\u00e3o @Model que possui os\nseguntes par\u00e2metros:   name : Nome do model  definition : Defini\u00e7\u00e3o das colunas. O objeto usado para as defini\u00e7\u00f5es \u00e9 o mesmo de\n     defini\u00e7\u00e3o do\n    Sequelize .   Exemplo:  import   {   ModelNames   }   from   ./ModelNames ;  import   {   BaseModel ,   BelongsTo ,   DataTypes ,   Model ,   SequelizeBaseModelAttr   }   from   protontype ;  @ Model ({ \n     name :   ModelNames . TASKS , \n     definition :   { \n         title :   { \n             type :   DataTypes . STRING , \n             allowNull :   false , \n             validate :   { \n                 notEmpty :   true \n             } \n         }, \n         done :   { \n             type :   DataTypes . BOOLEAN , \n             allowNull :   false , \n             defaultValue :   false \n         } \n     }  })  export   class   TasksModel   extends   BaseModel Task   {  }  export   interface   Task   extends   SequelizeBaseModelAttr   { \n     title :   string ; \n     done :   boolean ; \n     user_id :   number ;  }", 
            "title": "Criando Models"
        }, 
        {
            "location": "/models/#carregamento-dos-models", 
            "text": "Cada  BaseModel  ser\u00e1 carregado automaticamente na hora da sua instancia\u00e7\u00e3o. Geralmente o model sera carregado quando for usado por um  Router , por\u00e9m o carregamento poder\u00e1 ser for\u00e7ado atrav\u00e9s o  @LoadModel  decorator ou simplemente atrav\u00e9s do  new     @ LoadModel ( new   TaskModel ())  export   class   UsersModel   extends   BaseModel User   {  }", 
            "title": "Carregamento dos Models"
        }, 
        {
            "location": "/models/#adicionando-relacionamentos-e-outras-configuracoes-nos-models", 
            "text": "Um BaseModel permite sobreescrever o m\u00e9todo  configure() , que permite acessar a instancia do modelo Sequelize e os modelos j\u00e1 carregados e adicionar l\u00f3gicas e configura\u00e7\u00f5es:  export   class   UsersModel   extends   BaseModel User   { \n     public   configure () :   void   { \n         this . getInstance (). beforeCreate (( user :   any )   =   { \n             let   salt :   string   =   bcrypt . genSaltSync (); \n             user . password   =   bcrypt . hashSync ( user . password ,   salt ); \n         }); \n\n         this . getInstance (). hasMany ( this . ProtonDB . getModel ( Tasks ). getInstance ()); \n     }  }", 
            "title": "Adicionando relacionamentos e outras configura\u00e7\u00f5es nos Models"
        }, 
        {
            "location": "/models/#usando-decorators-para-criar-relacionamentos", 
            "text": "Alguns decorators est\u00e3os dispon\u00edveis para facilitar a adi\u00e7\u00e3o dos relacionamentos:  @ HasMany ( modelName :   string )  @ HasOne ( modelName :   string )  @ BelongsTo ( modelName :   string )  @ BelongsToMany ( modelName :   string ,   options :   Sequelize . AssociationOptionsBelongsToMany )   Estes podem ser usados como nos exemplos abaixo:  @ HasMany ( ModelNames . TASKS )  export   class   UsersModel   extends   BaseModel User   { \n     public   configure () :   void   { \n         this . getInstance (). beforeCreate (( user :   any )   =   { \n             let   salt :   string   =   bcrypt . genSaltSync (); \n             user . password   =   bcrypt . hashSync ( user . password ,   salt ); \n         }); \n     }  }   @ BelongsTo ( ModelNames . USERS )  export   class   TasksModel   extends   BaseModel Task   {  }   Para mais informa\u00e7\u00f5es sobre as possibilidades de configura\u00e7\u00f5es e uso dos Models, consultar a documenta\u00e7\u00e3o do Sequelize: http://docs.sequelizejs.com/en/v3/", 
            "title": "Usando decorators para criar relacionamentos"
        }, 
        {
            "location": "/config/", 
            "text": "Configura\u00e7\u00f5es\n\n\nConfigura\u00e7\u00e3o do projeto TypeScript\n\n\nAs seguintes configura\u00e7\u00f5es no \ntsconfig.json\n s\u00e3o necess\u00e1rias para o\nfuncionamento.\n\n\n{\n\n    \ncompilerOptions\n:\n \n{\n\n    \ntarget\n:\n \nes5\n,\n\n    \nmodule\n:\n \ncommonjs\n,\n\n    \nemitDecoratorMetadata\n:\n \ntrue\n,\n\n    \nexperimentalDecorators\n:\n \ntrue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nConfigura\u00e7\u00f5es da Aplica\u00e7\u00e3o\n\n\n{\n\n  \nport\n:\n \n3000\n,\n\n  \ndefaultRoutes\n:\n \ntrue\n,\n\n  \ndatabase\n:\n \n{\n\n    \nname\n:\n \nproton-example\n,\n\n    \nusername\n:\n \n,\n\n    \npassword\n:\n \n,\n\n    \noptions\n:\n \n{\n\n      \ndialect\n:\n \nsqlite\n,\n\n      \nstorage\n:\n \n./src/test/proton.sqlite\n,\n\n      \ndefine\n:\n \n{\n\n        \nunderscored\n:\n \ntrue\n\n      \n},\n\n      \nlogging\n:\n \nfalse\n\n    \n}\n\n  \n},\n\n  \ncors\n:\n \n{\n\n    \norigin\n:\n \n*\n,\n\n    \nmethods\n:\n \n[\nGET\n,\n \nPOST\n,\n \nOPTIONS\n,\n \nPUT\n,\n \nPATCH\n,\n \nDELETE\n],\n\n    \nallowedHeaders\n:\n \n[\nContent-Type\n,\n \nAuthorization\n]\n\n  \n},\n\n  \njwtSecret\n:\n \nsecret\n,\n\n  \njwtSession\n:\n \n{\n\n    \nsession\n:\n \nfalse\n\n  \n},\n\n  \nlogger\n:\n \n{\n\n    \nenabled\n:\n \nfalse\n,\n\n    \ntransports\n:\n \n[\n\n      \n{\n\n        \ntype\n:\n \nfile\n,\n\n        \noptions\n:\n \n{\n\n          \nfilename\n:\n \n./test/logs.log\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \ntype\n:\n \nconsole\n\n      \n}\n\n    \n]\n\n  \n},\n\n  \nhttps\n:\n \n{\n\n    \nenabled\n:\n \nfalse\n,\n\n    \nkey\n:\n \n./src/test/cert/cert.key\n,\n\n    \ncert\n:\n \n./src/test/cert/cert.cert\n\n  \n}\n\n\n}", 
            "title": "Configura\u00e7\u00f5es"
        }, 
        {
            "location": "/config/#configuracoes", 
            "text": "", 
            "title": "Configura\u00e7\u00f5es"
        }, 
        {
            "location": "/config/#configuracao-do-projeto-typescript", 
            "text": "As seguintes configura\u00e7\u00f5es no  tsconfig.json  s\u00e3o necess\u00e1rias para o\nfuncionamento.  { \n     compilerOptions :   { \n     target :   es5 , \n     module :   commonjs , \n     emitDecoratorMetadata :   true , \n     experimentalDecorators :   true \n     }  }", 
            "title": "Configura\u00e7\u00e3o do projeto TypeScript"
        }, 
        {
            "location": "/config/#configuracoes-da-aplicacao", 
            "text": "{ \n   port :   3000 , \n   defaultRoutes :   true , \n   database :   { \n     name :   proton-example , \n     username :   , \n     password :   , \n     options :   { \n       dialect :   sqlite , \n       storage :   ./src/test/proton.sqlite , \n       define :   { \n         underscored :   true \n       }, \n       logging :   false \n     } \n   }, \n   cors :   { \n     origin :   * , \n     methods :   [ GET ,   POST ,   OPTIONS ,   PUT ,   PATCH ,   DELETE ], \n     allowedHeaders :   [ Content-Type ,   Authorization ] \n   }, \n   jwtSecret :   secret , \n   jwtSession :   { \n     session :   false \n   }, \n   logger :   { \n     enabled :   false , \n     transports :   [ \n       { \n         type :   file , \n         options :   { \n           filename :   ./test/logs.log \n         } \n       }, \n       { \n         type :   console \n       } \n     ] \n   }, \n   https :   { \n     enabled :   false , \n     key :   ./src/test/cert/cert.key , \n     cert :   ./src/test/cert/cert.cert \n   }  }", 
            "title": "Configura\u00e7\u00f5es da Aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/bootstrap/", 
            "text": "Iniciando aplica\u00e7\u00e3o\n\n\nlet\n \nexpressApp\n \n=\n \nnew\n \nProtonApplication\n();\n\n\nexpressApp\n\n    \n.\nwithAuthMiddleware\n(\nnew\n \nJWTAuthMiddleware\n())\n\n    \n.\naddRouter\n(\nnew\n \nTasksRouter\n())\n\n    \n.\naddMiddleware\n(\nnew\n \nTasksMiddleware\n())\n\n    \n.\nbootstrap\n();\n\n\n\n\n\n\nExemplo de uso completo\n\n\nhttps://github.com/linck/protontype-example", 
            "title": "Iniciando Aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/bootstrap/#iniciando-aplicacao", 
            "text": "let   expressApp   =   new   ProtonApplication ();  expressApp \n     . withAuthMiddleware ( new   JWTAuthMiddleware ()) \n     . addRouter ( new   TasksRouter ()) \n     . addMiddleware ( new   TasksMiddleware ()) \n     . bootstrap ();", 
            "title": "Iniciando aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/bootstrap/#exemplo-de-uso-completo", 
            "text": "https://github.com/linck/protontype-example", 
            "title": "Exemplo de uso completo"
        }, 
        {
            "location": "/license/", 
            "text": "The MIT License\n\n\nCopyright (c) 2017 Humberto Machado\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.", 
            "title": "License"
        }
    ]
}