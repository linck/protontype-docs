{
    "docs": [
        {
            "location": "/", 
            "text": "ProtonType\n\n\nUm simples web framework feito em TypeScript.\n\n\nO ProtonType tem como objetivo tornar simples e agrad\u00e1vel o desenvolvimento de APIs REST e cria\u00e7\u00e3o de modelos de banco de dados. Utilizando \nExpress\n e \nSequelize ORM\n ajuda na cria\u00e7\u00e3o de aplica\u00e7\u00f5es web robustas.\n\n\nInstala\u00e7\u00e3o\n\n\nnpm install protontype --save\n\n\n\n\n\nModels\n\n\n    \nimport\n \n{\n \nBaseModel\n,\n \nSequelizeBaseModelAttr\n,\n \nModel\n,\n \nDataTypes\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \n@\nModel\n({\n\n        \nname\n:\n \nParticles\n,\n\n        \ndefinition\n:\n \n{\n\n            \nname\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nSTRING\n\n            \n},\n\n            \nsymbol\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nSTRING\n\n            \n},\n\n            \nmass\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nBIGINT\n\n            \n}\n\n\n        \n}\n\n    \n})\n\n    \n@\nHasMany\n(\nSubatomicParticles\n)\n\n    \n@\nBelongsTo\n(\nAtoms\n)\n\n    \nexport\n \nclass\n \nParticlesModel\n \nextends\n \nBaseModel\nParticle\n \n{\n\n\n    \n}\n\n\n    \nexport\n \ninterface\n \nParticle\n \nextends\n \nSequelizeBaseModelAttr\n \n{\n\n        \nname\n:\n \nstring\n;\n\n        \nsymbol\n:\n \nstring\n;\n\n        \nmass\n:\n \nnumber\n;\n\n    \n}\n\n\n\n\n\n\nRouter\n\n\n    \nimport\n \n{\n \nParticlesModel\n \n}\n \nfrom\n \n./ParticlesModel\n;\n\n    \nimport\n \n{\n \nBaseCrudRouter\n,\n \nRouterClass\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \n@\nRouterClass\n({\n\n        \nbaseUrl\n:\n \n/particles\n,\n\n        \nmodelInstances\n:\n \n[\nnew\n \nParticlesModel\n()],\n\n        \nmiddlewares\n:\n \n[\nnew\n \nParticlesMiddleware\n()]\n\n    \n})\n\n    \nexport\n \nclass\n \nParticlesRouter\n \nextends\n \nBaseCrudRouter\n \n{\n\n\n        \n@\nRoute\n({\n\n            \nendpoint\n:\n \n/list\n,\n\n            \nmethod\n:\n \nMethod\n.\nGET\n,\n\n            \nmodelName\n:\n \nParticles\n,\n\n            \nmiddlewares\n:\n \n[\n \nnew\n \nAccelerateParticlesMiddleware\n()\n \n]\n\n        \n})\n\n        \nseparateOneParticle\n(\nparams\n:\n \nRouterFunctionParams\n)\n \n{\n\n            \nparams\n.\nres\n.\nsend\n(\nPr\u00f3ton\n);\n\n        \n}\n\n\n    \n}\n\n\n\n\n\n\nMiddlewares\n\n\nimport\n \n{\n \nMiddleware\n,\n \nMiddlewareFunctionParams\n,\n \nProtonMiddleware\n \n}\n \nfrom\n \nprotontype\n;\n\n\nexport\n \nclass\n \nParticlesMiddleware\n \nextends\n \nProtonMiddleware\n \n{\n\n\n    \n@\nMiddleware\n()\n\n    \nprintParticleName\n(\nparams\n:\n \nMiddlewareFunctionParams\n)\n \n{\n\n        \ncosole\n.\nlog\n(\nPr\u00f3ton\n);\n\n        \nparams\n.\nnext\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nBootstraping\n\n\n    \nimport\n \n{\n \nParticlesRouter\n \n}\n \nfrom\n \n./ParticlesRouter\n;\n\n    \nimport\n \n{\n \nProtonApplication\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \nnew\n \nProtonApplication\n()\n\n        \n.\naddRouter\n(\nnew\n \nParticlesRouter\n())\n\n        \n.\naddMiddleware\n(\nnew\n \nParticlesMiddleware\n())\n\n        \n.\nbootstrap\n();\n\n\n\n\n\n\nExemplos\n\n\nhttps://github.com/linck/protontype-example\n\n\nhttps://github.com/linck/proton-quickstart\n\n\nEnglish", 
            "title": "Home"
        }, 
        {
            "location": "/#protontype", 
            "text": "Um simples web framework feito em TypeScript.  O ProtonType tem como objetivo tornar simples e agrad\u00e1vel o desenvolvimento de APIs REST e cria\u00e7\u00e3o de modelos de banco de dados. Utilizando  Express  e  Sequelize ORM  ajuda na cria\u00e7\u00e3o de aplica\u00e7\u00f5es web robustas.", 
            "title": "ProtonType"
        }, 
        {
            "location": "/#instalacao", 
            "text": "npm install protontype --save", 
            "title": "Instala\u00e7\u00e3o"
        }, 
        {
            "location": "/#models", 
            "text": "import   {   BaseModel ,   SequelizeBaseModelAttr ,   Model ,   DataTypes   }   from   protontype ; \n\n     @ Model ({ \n         name :   Particles , \n         definition :   { \n             name :   { \n                 type :   DataTypes . STRING \n             }, \n             symbol :   { \n                 type :   DataTypes . STRING \n             }, \n             mass :   { \n                 type :   DataTypes . BIGINT \n             } \n\n         } \n     }) \n     @ HasMany ( SubatomicParticles ) \n     @ BelongsTo ( Atoms ) \n     export   class   ParticlesModel   extends   BaseModel Particle   { \n\n     } \n\n     export   interface   Particle   extends   SequelizeBaseModelAttr   { \n         name :   string ; \n         symbol :   string ; \n         mass :   number ; \n     }", 
            "title": "Models"
        }, 
        {
            "location": "/#router", 
            "text": "import   {   ParticlesModel   }   from   ./ParticlesModel ; \n     import   {   BaseCrudRouter ,   RouterClass   }   from   protontype ; \n\n     @ RouterClass ({ \n         baseUrl :   /particles , \n         modelInstances :   [ new   ParticlesModel ()], \n         middlewares :   [ new   ParticlesMiddleware ()] \n     }) \n     export   class   ParticlesRouter   extends   BaseCrudRouter   { \n\n         @ Route ({ \n             endpoint :   /list , \n             method :   Method . GET , \n             modelName :   Particles , \n             middlewares :   [   new   AccelerateParticlesMiddleware ()   ] \n         }) \n         separateOneParticle ( params :   RouterFunctionParams )   { \n             params . res . send ( Pr\u00f3ton ); \n         } \n\n     }", 
            "title": "Router"
        }, 
        {
            "location": "/#middlewares", 
            "text": "import   {   Middleware ,   MiddlewareFunctionParams ,   ProtonMiddleware   }   from   protontype ;  export   class   ParticlesMiddleware   extends   ProtonMiddleware   { \n\n     @ Middleware () \n     printParticleName ( params :   MiddlewareFunctionParams )   { \n         cosole . log ( Pr\u00f3ton ); \n         params . next (); \n     }  }", 
            "title": "Middlewares"
        }, 
        {
            "location": "/#bootstraping", 
            "text": "import   {   ParticlesRouter   }   from   ./ParticlesRouter ; \n     import   {   ProtonApplication   }   from   protontype ; \n\n     new   ProtonApplication () \n         . addRouter ( new   ParticlesRouter ()) \n         . addMiddleware ( new   ParticlesMiddleware ()) \n         . bootstrap ();", 
            "title": "Bootstraping"
        }, 
        {
            "location": "/#exemplos", 
            "text": "https://github.com/linck/protontype-example  https://github.com/linck/proton-quickstart  English", 
            "title": "Exemplos"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quick Start - Criando uma API em 5 passos\n\n\nEstrutura de pastas e configura\u00e7\u00f5es iniciais\n\n\n    mkdir proton-quickstart\n    \ncd\n proton-quickstart\n    npm init\n    mkdir src\n    npm install protontype --save\n\n\n\n\n\nCriar o arquivo tsconfig.json na raiz do projeto\n\n\n    \n{\n\n      \ncompilerOptions\n:\n \n{\n\n        \ntarget\n:\n \nes5\n,\n\n        \nmodule\n:\n \ncommonjs\n,\n\n        \nemitDecoratorMetadata\n:\n \ntrue\n,\n\n        \nexperimentalDecorators\n:\n \ntrue\n,\n\n        \noutDir\n:\n \ndist\n\n      \n},\n\n      \nexclude\n:\n \n[\n\n        \nnode_modules\n,\n\n        \ndist\n\n      \n]\n\n    \n}\n\n\n\n\n\n\nModel\n\n\nCriar um arquivo ParticlesModel.ts\n\n\n    \nimport\n \n{\n \nBaseModel\n,\n \nSequelizeBaseModelAttr\n,\n \nModel\n,\n \nDataTypes\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \n@\nModel\n({\n\n        \nname\n:\n \nParticles\n,\n\n        \ndefinition\n:\n \n{\n\n            \nname\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nSTRING\n\n            \n},\n\n            \nsymbol\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nSTRING\n\n            \n},\n\n            \nmass\n:\n \n{\n\n                \ntype\n:\n \nDataTypes\n.\nBIGINT\n\n            \n}\n\n\n        \n}\n\n    \n})\n\n    \nexport\n \nclass\n \nParticlesModel\n \nextends\n \nBaseModel\nParticle\n \n{\n\n\n    \n}\n\n\n    \nexport\n \ninterface\n \nParticle\n \nextends\n \nSequelizeBaseModelAttr\n \n{\n\n        \nname\n:\n \nstring\n;\n\n        \nsymbol\n:\n \nstring\n;\n\n        \nmass\n:\n \nnumber\n;\n\n    \n}\n\n\n\n\n\n\nRouter\n\n\nCriar arquivo ParticlesRouter.ts\n\n\n    \nimport\n \n{\n \nParticlesModel\n \n}\n \nfrom\n \n./ParticlesModel\n;\n\n    \nimport\n \n{\n \nBaseCrudRouter\n,\n \nRouterClass\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \n@\nRouterClass\n({\n\n        \nbaseUrl\n:\n \n/particles\n,\n\n        \nmodelInstances\n:\n \n[\nnew\n \nParticlesModel\n()]\n\n    \n})\n\n    \nexport\n \nclass\n \nParticlesRouter\n \nextends\n \nBaseCrudRouter\n \n{\n\n\n    \n}\n\n\n\n\n\n\nMain\n\n\nCriar arquivo Main.ts\n\n\n    \nimport\n \n{\n \nParticlesRouter\n \n}\n \nfrom\n \n./ParticlesRouter\n;\n\n    \nimport\n \n{\n \nProtonApplication\n \n}\n \nfrom\n \nprotontype\n;\n\n\n    \nnew\n \nProtonApplication\n()\n\n        \n.\naddRouter\n(\nnew\n \nParticlesRouter\n())\n\n        \n.\nbootstrap\n();\n\n\n\n\n\n\nCompilando e Rodando Aplica\u00e7\u00e3o\n\n\n    tsc\n    node dist/Main.ts\n\n\n\n\n\nTestando a API\n\n\nPor padr\u00e3o, a aplica\u00e7\u00e3o usar\u00e1 um banco de dados sqlite. \nSer\u00e1 criado um arquivo proton.sqlite na raiz do projeto.\n\n\nOs endpoints abaixo j\u00e1 estar\u00e3o dispon\u00edveis:\n\n\n\n\nGET /particles\n - Lista todos os registos da tabela Particles\n\n\nPOST /particles\n - Cria um registro na tabela Particles\n\n\nGET /particles/:id\n - Consulta um registro da tabela Particles\n\n\nPUT /particles/:id\n - Atualiza um registro da tabela Particles\n\n\nDELETE /particles/:id\n - Remove um registro da tabela Particles\n\n\n\n\nPodera testar atrav\u00e9s do app \nPostman\n ou outro da sua prefer\u00eancia.\n\n\nC\u00f3digo completo do quick start\n\n\nhttps://github.com/linck/proton-quickstart", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quickstart/#quick-start-criando-uma-api-em-5-passos", 
            "text": "", 
            "title": "Quick Start - Criando uma API em 5 passos"
        }, 
        {
            "location": "/quickstart/#estrutura-de-pastas-e-configuracoes-iniciais", 
            "text": "mkdir proton-quickstart\n     cd  proton-quickstart\n    npm init\n    mkdir src\n    npm install protontype --save  Criar o arquivo tsconfig.json na raiz do projeto       { \n       compilerOptions :   { \n         target :   es5 , \n         module :   commonjs , \n         emitDecoratorMetadata :   true , \n         experimentalDecorators :   true , \n         outDir :   dist \n       }, \n       exclude :   [ \n         node_modules , \n         dist \n       ] \n     }", 
            "title": "Estrutura de pastas e configura\u00e7\u00f5es iniciais"
        }, 
        {
            "location": "/quickstart/#model", 
            "text": "Criar um arquivo ParticlesModel.ts       import   {   BaseModel ,   SequelizeBaseModelAttr ,   Model ,   DataTypes   }   from   protontype ; \n\n     @ Model ({ \n         name :   Particles , \n         definition :   { \n             name :   { \n                 type :   DataTypes . STRING \n             }, \n             symbol :   { \n                 type :   DataTypes . STRING \n             }, \n             mass :   { \n                 type :   DataTypes . BIGINT \n             } \n\n         } \n     }) \n     export   class   ParticlesModel   extends   BaseModel Particle   { \n\n     } \n\n     export   interface   Particle   extends   SequelizeBaseModelAttr   { \n         name :   string ; \n         symbol :   string ; \n         mass :   number ; \n     }", 
            "title": "Model"
        }, 
        {
            "location": "/quickstart/#router", 
            "text": "Criar arquivo ParticlesRouter.ts       import   {   ParticlesModel   }   from   ./ParticlesModel ; \n     import   {   BaseCrudRouter ,   RouterClass   }   from   protontype ; \n\n     @ RouterClass ({ \n         baseUrl :   /particles , \n         modelInstances :   [ new   ParticlesModel ()] \n     }) \n     export   class   ParticlesRouter   extends   BaseCrudRouter   { \n\n     }", 
            "title": "Router"
        }, 
        {
            "location": "/quickstart/#main", 
            "text": "Criar arquivo Main.ts       import   {   ParticlesRouter   }   from   ./ParticlesRouter ; \n     import   {   ProtonApplication   }   from   protontype ; \n\n     new   ProtonApplication () \n         . addRouter ( new   ParticlesRouter ()) \n         . bootstrap ();   Compilando e Rodando Aplica\u00e7\u00e3o      tsc\n    node dist/Main.ts", 
            "title": "Main"
        }, 
        {
            "location": "/quickstart/#testando-a-api", 
            "text": "Por padr\u00e3o, a aplica\u00e7\u00e3o usar\u00e1 um banco de dados sqlite. \nSer\u00e1 criado um arquivo proton.sqlite na raiz do projeto.  Os endpoints abaixo j\u00e1 estar\u00e3o dispon\u00edveis:   GET /particles  - Lista todos os registos da tabela Particles  POST /particles  - Cria um registro na tabela Particles  GET /particles/:id  - Consulta um registro da tabela Particles  PUT /particles/:id  - Atualiza um registro da tabela Particles  DELETE /particles/:id  - Remove um registro da tabela Particles   Podera testar atrav\u00e9s do app  Postman  ou outro da sua prefer\u00eancia.  C\u00f3digo completo do quick start  https://github.com/linck/proton-quickstart", 
            "title": "Testando a API"
        }, 
        {
            "location": "/router/", 
            "text": "Router\n\n\nA API do Protontype disponibiliza a classe \nExpressRouter\n para ser base dos routers.\n\n\nCriando um Router\n\n\nPara criar uma classe router basta estender a classe \nExpressRouter\n\n\nimport\n \n{\n \nExpressRouter\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\nexport\n \nclass\n \nTasksRouter\n \nextends\n \nExpressRouter\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\nPara configurar uma classe Router deve-se usar o decorator \n@RouterClass()\n\n\nimport\n \n{\n \nExpressRouter\n,\n \nRouterClass\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmodelInstances\n:\n \n[\n \nnew\n \nTaskModel\n(),\n \nnew\n \nOtherModel\n()\n \n],\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyMiddleware\n(),\n \nnew\n \nOtherMiddleware\n()\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nTasksRouter\n \nextends\n \nExpressRouter\n \n{\n\n        \n...\n\n\n}\n\n\n\n\n\n\nUma classe Router poder\u00e1 conter v\u00e1rias fun\u00e7\u00f5es de rotas, chamadas \nRouter Functions\n. Para definir e configurar uma \nrouter function\n deve-se usar o decorator \n@Route()\n. Uma \nRouter Function\n recebe como par\u00e2metro um objeto do tipo \nRouterFunctionParams\n\n\nimport\n \n{\n \nExpressRouter\n,\n \nRouterFunctionParams\n,\n \nMethod\n,\n \nRoute\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmodelInstances\n:\n \n[\n \nnew\n \nTaskModel\n(),\n \nnew\n \nOtherModel\n()\n \n],\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyMiddleware\n(),\n \nnew\n \nOtherMiddleware\n()\n \n]\n\n\n})\n\n\nexport\n \nclass\n \nTasksRouter\n \nextends\n \nExpressRouter\n \n{\n\n\n    \n@\nRoute\n({\n\n        \nendpoint\n:\n \n/\n,\n\n        \nmethod\n:\n \nMethod\n.\nGET\n\n    \n})\n\n    \nlistTasks\n(\nparams\n:\n \nRouterFunctionParams\n)\n \n{\n\n        \nparams\n.\nres\n.\nsend\n({\nid\n:\n \n1\n,\n \ntitle\n:\n \nTask de teste\n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\n@RouterClass()\n\n\nUsado para definir uma classe que cont\u00e9m rotas. Todas classes do tipo \nExpressRouter\n suportam esta anota\u00e7\u00e3o.\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmodelInstances\n:\n \n[\n \nnew\n \nTaskModel\n(),\n \nnew\n \nOtherModel\n()\n \n],\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyRouterMiddleware\n(),\n \nnew\n \nOtherRouterMiddleware\n()\n \n]\n\n\n})\n\n\n\n\n\n\nPropriedades:\n\n\n\n\nbaseUrl\n: Url base do roteador. Todas rodas ser\u00e3o criadas no padr\u00e3o \nbaseUrl + endpoint\n\n\nmodelInstances\n: Inst\u00e2ncias dos Models que o router ir\u00e1 usar.\n\n\nmiddlewares\n: Middlewares que atuar\u00e3o para todas as rotas definidas neste router\n\n\n\n\n@Route()\n\n\nUsado para definir e configurar as rotas dentro de um router.\n\n\n@\nRoute\n({\n\n    \nendpoint\n:\n \n/list\n,\n\n    \nmethod\n:\n \nMethod\n.\nGET\n,\n\n    \nmodelName\n:\n \nTask\n,\n\n    \nuseAuth\n:\n \ntrue\n,\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nMyRouteMiddleware\n(),\n \nnew\n \nOtherRouteMiddleware\n()\n \n]\n\n\n})\n\n\n\n\n\n\nPropriedades:\n\n\n\n\nendpoint\n: Define o endpoint da rota. A url desta rota ser\u00e1 formada pela \nbaseUrl\n (definida na \n@RouterClass\n) + \nendpoint\n. Exemplo: \nhttp://locathost/tasks/list\n\n\nmethod\n: Verbo HTTP usado para esta rota. GET, POST, DELETE...\n\n\nmodelName\n: Nome do model que ser\u00e1 injetado no par\u00e2metro \nmodel\n de \nRouterFunctionParams\n\n\nuseAuth\n: Indica se esta rota ser\u00e1 autenticada por algum middleware de autentica\u00e7\u00e3o (\nAuthMiddleware\n)\n\n\nmiddlewares\n: Middlewares que atuar\u00e3o somente para esta rota espec\u00edfica\n\n\n\n\nRouterFunctionParams\n\n\nToda \nRouter Function\n deve ter como par\u00e2metro um objeto do tipo \nRouterFunctionParams\n\n\n@\nRoute\n({\n\n    \nendpoint\n:\n \n/\n,\n\n    \nmethod\n:\n \nMethod\n.\nGET\n\n\n})\n\n\nlistTasks\n(\nparams\n:\n \nRouterFunctionParams\n)\n \n{\n\n    \nconsole\n.\nlog\n(\nparams\n.\nreq\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\nres\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\nmodel\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\napp\n);\n\n\n}\n\n\n\n\n\n\nPropriedades:\n\n\n\n\nreq\n: Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do \nExpress\n.\n\n\nres\n: Objeto usado para enviar a resposta http. Corresponde ao objeto de response do \nExpress\n.\n\n\nmodel\n: Inst\u00e2ncia do model especificado em \nmodelName\n de \n@Route\n\n\napp\n: Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.", 
            "title": "Routers"
        }, 
        {
            "location": "/router/#router", 
            "text": "A API do Protontype disponibiliza a classe  ExpressRouter  para ser base dos routers.", 
            "title": "Router"
        }, 
        {
            "location": "/router/#criando-um-router", 
            "text": "Para criar uma classe router basta estender a classe  ExpressRouter  import   {   ExpressRouter   }   from   protontype ;  export   class   TasksRouter   extends   ExpressRouter   { \n     ...  }   Para configurar uma classe Router deve-se usar o decorator  @RouterClass()  import   {   ExpressRouter ,   RouterClass   }   from   protontype ;  @ RouterClass ({ \n     baseUrl :   /tasks , \n     modelInstances :   [   new   TaskModel (),   new   OtherModel ()   ], \n     middlewares :   [   new   MyMiddleware (),   new   OtherMiddleware ()   ]  })  export   class   TasksRouter   extends   ExpressRouter   { \n         ...  }   Uma classe Router poder\u00e1 conter v\u00e1rias fun\u00e7\u00f5es de rotas, chamadas  Router Functions . Para definir e configurar uma  router function  deve-se usar o decorator  @Route() . Uma  Router Function  recebe como par\u00e2metro um objeto do tipo  RouterFunctionParams  import   {   ExpressRouter ,   RouterFunctionParams ,   Method ,   Route   }   from   protontype ;  @ RouterClass ({ \n     baseUrl :   /tasks , \n     modelInstances :   [   new   TaskModel (),   new   OtherModel ()   ], \n     middlewares :   [   new   MyMiddleware (),   new   OtherMiddleware ()   ]  })  export   class   TasksRouter   extends   ExpressRouter   { \n\n     @ Route ({ \n         endpoint :   / , \n         method :   Method . GET \n     }) \n     listTasks ( params :   RouterFunctionParams )   { \n         params . res . send ({ id :   1 ,   title :   Task de teste }); \n     }  }", 
            "title": "Criando um Router"
        }, 
        {
            "location": "/router/#routerclass", 
            "text": "Usado para definir uma classe que cont\u00e9m rotas. Todas classes do tipo  ExpressRouter  suportam esta anota\u00e7\u00e3o.  @ RouterClass ({ \n     baseUrl :   /tasks , \n     modelInstances :   [   new   TaskModel (),   new   OtherModel ()   ], \n     middlewares :   [   new   MyRouterMiddleware (),   new   OtherRouterMiddleware ()   ]  })   Propriedades:   baseUrl : Url base do roteador. Todas rodas ser\u00e3o criadas no padr\u00e3o  baseUrl + endpoint  modelInstances : Inst\u00e2ncias dos Models que o router ir\u00e1 usar.  middlewares : Middlewares que atuar\u00e3o para todas as rotas definidas neste router", 
            "title": "@RouterClass()"
        }, 
        {
            "location": "/router/#route", 
            "text": "Usado para definir e configurar as rotas dentro de um router.  @ Route ({ \n     endpoint :   /list , \n     method :   Method . GET , \n     modelName :   Task , \n     useAuth :   true , \n     middlewares :   [   new   MyRouteMiddleware (),   new   OtherRouteMiddleware ()   ]  })   Propriedades:   endpoint : Define o endpoint da rota. A url desta rota ser\u00e1 formada pela  baseUrl  (definida na  @RouterClass ) +  endpoint . Exemplo:  http://locathost/tasks/list  method : Verbo HTTP usado para esta rota. GET, POST, DELETE...  modelName : Nome do model que ser\u00e1 injetado no par\u00e2metro  model  de  RouterFunctionParams  useAuth : Indica se esta rota ser\u00e1 autenticada por algum middleware de autentica\u00e7\u00e3o ( AuthMiddleware )  middlewares : Middlewares que atuar\u00e3o somente para esta rota espec\u00edfica", 
            "title": "@Route()"
        }, 
        {
            "location": "/router/#routerfunctionparams", 
            "text": "Toda  Router Function  deve ter como par\u00e2metro um objeto do tipo  RouterFunctionParams  @ Route ({ \n     endpoint :   / , \n     method :   Method . GET  })  listTasks ( params :   RouterFunctionParams )   { \n     console . log ( params . req ); \n     console . log ( params . res ); \n     console . log ( params . model ); \n     console . log ( params . app );  }   Propriedades:   req : Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do  Express .  res : Objeto usado para enviar a resposta http. Corresponde ao objeto de response do  Express .  model : Inst\u00e2ncia do model especificado em  modelName  de  @Route  app : Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.", 
            "title": "RouterFunctionParams"
        }, 
        {
            "location": "/middlewares/", 
            "text": "Middlewares\n\n\nCriando Middlewares\n\n\nPra criar uma classe middleware base estender \nProtonMiddleware\n. Um middleware poder\u00e1 ter um Middleware Function.\n\n\nExemplo:\n\n\nimport\n \n{\n \nMiddleware\n,\n \nMiddlewareFunctionParams\n,\n \nProtonMiddleware\n \n}\n \nfrom\n \nprotontype\n;\n\n\nexport\n \nclass\n \nExampleMiddleware\n \nextends\n \nProtonMiddleware\n \n{\n\n\n    \n@\nMiddleware\n()\n\n    \nexampleMiddlewareFunc\n(\nparams\n:\n \nMiddlewareFunctionParams\n)\n \n{\n\n        \ncosole\n.\nlog\n(\nparams\n.\nreq\n);\n\n        \nconsole\n.\nlog\n(\nparams\n.\nres\n);\n\n        \nparams\n.\nnext\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nMiddleware Function\n\n\nUm \nMiddleware Function\n \u00e9 uma fun\u00e7\u00e3o dentro de uma classe \nProtonMiddleware\n  anotada com o decorator \n@Middleware\n e tem como par\u00e2metro um objeto do tipo \nMiddlewareFunctionParams\n. Esta fun\u00e7\u00e3o define o comportamento do middleware.\n\n\n@\nMiddleware\n()\n\n\nexampleMiddlewareFunc\n(\nparams\n:\n \nMiddlewareFunctionParams\n)\n \n{\n\n    \ncosole\n.\nlog\n(\nparams\n.\nreq\n);\n\n    \nconsole\n.\nlog\n(\nparams\n.\nres\n);\n\n    \nparams\n.\nnext\n();\n\n\n}\n\n\n\n\n\n\n@Middleware\n\n\nO decorator \n@Middleware()\n indica qual fun\u00e7\u00e3o cont\u00e9m o comportamento do middleware.\n\n\nPropriedades\n\n\n\n\nmodelName: Indica qual o Model ser\u00e1 injetado como par\u00e2metro no \nMiddlewareFunctionParams\n. Opcional\n\n\n\n\nMiddlewareFunctionParams\n\n\nPar\u00e2metros de um \nMiddleware Function\n\n\nPropriedades\n\n\n\n\nreq\n: Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do \nExpress\n.\n\n\nres\n: Objeto usado para enviar a resposta http. Corresponde ao objeto de response do \nExpress\n.\n\n\nnext\n: fun\u00e7\u00e3o usada para chamar o pr\u00f3ximo middleware da cadeia\n\n\nmodel\n: Inst\u00e2ncia do model especificado em \nmodelName\n de \n@Middleware()\n\n\napp\n: Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.\n\n\n\n\nEscopo dos Middlewares\n\n\nOs middlewares podem atuar em diferentes escopos\n\n\nEscopo de Aplica\u00e7\u00e3o\n\n\nEste middleware atuar\u00e1 no escopo da aplica\u00e7\u00e3o, ou seja antes de qualquer rota configurada.\nPara tornar um middleware global, deve-se adicionar ele no bootstrap da aplica\u00e7\u00e3o:\n\n\nnew\n \nProtonApplication\n()\n\n    \n.\naddMiddleware\n(\nnew\n \nExampleMiddleware\n())\n\n    \n.\naddMiddleware\n(\nnew\n \nExampleMiddleware2\n())\n\n    \n.\nbootstrap\n();\n\n\n\n\n\n\nEscopo de Router\n\n\nEste middleware atuar\u00e1 para todas as \nRouter Functions\n dentro de uma classe \nExpressRouter\n.\nPara adicionar middlewares para atuar no escopo do router, este deve ser configurado no decorator \n@RouterClass()\n:\n\n\n@\nRouterClass\n({\n\n    \nbaseUrl\n:\n \n/tasks\n,\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nExampleMiddleware\n(),\n \nnew\n \nExampleMiddleware2\n()\n \n]\n\n\n})\n\n\n\n\n\n\nEscopo de Rota (Router Function)\n\n\nEste middleware atuar\u00e1 somente para aquela rota espec\u00edfica. Para adicionar middlewares ao escopo da rota, este deve ser configurado no decorator \n@Route()\n:\n\n\n@\nRoute\n({\n\n    \nendpoint\n:\n \n/list\n,\n\n    \nmethod\n:\n \nMethod\n.\nGET\n,\n\n    \nmiddlewares\n:\n \n[\n \nnew\n \nExampleMiddleware\n(),\n \nnew\n \nExampleMiddleware2\n()\n \n]\n\n\n})", 
            "title": "Middewares"
        }, 
        {
            "location": "/middlewares/#middlewares", 
            "text": "", 
            "title": "Middlewares"
        }, 
        {
            "location": "/middlewares/#criando-middlewares", 
            "text": "Pra criar uma classe middleware base estender  ProtonMiddleware . Um middleware poder\u00e1 ter um Middleware Function.  Exemplo:  import   {   Middleware ,   MiddlewareFunctionParams ,   ProtonMiddleware   }   from   protontype ;  export   class   ExampleMiddleware   extends   ProtonMiddleware   { \n\n     @ Middleware () \n     exampleMiddlewareFunc ( params :   MiddlewareFunctionParams )   { \n         cosole . log ( params . req ); \n         console . log ( params . res ); \n         params . next (); \n     }  }", 
            "title": "Criando Middlewares"
        }, 
        {
            "location": "/middlewares/#middleware-function", 
            "text": "Um  Middleware Function  \u00e9 uma fun\u00e7\u00e3o dentro de uma classe  ProtonMiddleware   anotada com o decorator  @Middleware  e tem como par\u00e2metro um objeto do tipo  MiddlewareFunctionParams . Esta fun\u00e7\u00e3o define o comportamento do middleware.  @ Middleware ()  exampleMiddlewareFunc ( params :   MiddlewareFunctionParams )   { \n     cosole . log ( params . req ); \n     console . log ( params . res ); \n     params . next ();  }", 
            "title": "Middleware Function"
        }, 
        {
            "location": "/middlewares/#middleware", 
            "text": "O decorator  @Middleware()  indica qual fun\u00e7\u00e3o cont\u00e9m o comportamento do middleware.  Propriedades   modelName: Indica qual o Model ser\u00e1 injetado como par\u00e2metro no  MiddlewareFunctionParams . Opcional", 
            "title": "@Middleware"
        }, 
        {
            "location": "/middlewares/#middlewarefunctionparams", 
            "text": "Par\u00e2metros de um  Middleware Function  Propriedades   req : Objeto que cont\u00e9m a requisi\u00e7\u00e3o http. Corresponde ao objeto de request do  Express .  res : Objeto usado para enviar a resposta http. Corresponde ao objeto de response do  Express .  next : fun\u00e7\u00e3o usada para chamar o pr\u00f3ximo middleware da cadeia  model : Inst\u00e2ncia do model especificado em  modelName  de  @Middleware()  app : Inst\u00e2ncia da aplica\u00e7\u00e3o Protontype. Por meio dela pode-se acessar as propriedades da aplica\u00e7\u00e3o.", 
            "title": "MiddlewareFunctionParams"
        }, 
        {
            "location": "/middlewares/#escopo-dos-middlewares", 
            "text": "Os middlewares podem atuar em diferentes escopos", 
            "title": "Escopo dos Middlewares"
        }, 
        {
            "location": "/middlewares/#escopo-de-aplicacao", 
            "text": "Este middleware atuar\u00e1 no escopo da aplica\u00e7\u00e3o, ou seja antes de qualquer rota configurada.\nPara tornar um middleware global, deve-se adicionar ele no bootstrap da aplica\u00e7\u00e3o:  new   ProtonApplication () \n     . addMiddleware ( new   ExampleMiddleware ()) \n     . addMiddleware ( new   ExampleMiddleware2 ()) \n     . bootstrap ();", 
            "title": "Escopo de Aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/middlewares/#escopo-de-router", 
            "text": "Este middleware atuar\u00e1 para todas as  Router Functions  dentro de uma classe  ExpressRouter .\nPara adicionar middlewares para atuar no escopo do router, este deve ser configurado no decorator  @RouterClass() :  @ RouterClass ({ \n     baseUrl :   /tasks , \n     middlewares :   [   new   ExampleMiddleware (),   new   ExampleMiddleware2 ()   ]  })", 
            "title": "Escopo de Router"
        }, 
        {
            "location": "/middlewares/#escopo-de-rota-router-function", 
            "text": "Este middleware atuar\u00e1 somente para aquela rota espec\u00edfica. Para adicionar middlewares ao escopo da rota, este deve ser configurado no decorator  @Route() :  @ Route ({ \n     endpoint :   /list , \n     method :   Method . GET , \n     middlewares :   [   new   ExampleMiddleware (),   new   ExampleMiddleware2 ()   ]  })", 
            "title": "Escopo de Rota (Router Function)"
        }, 
        {
            "location": "/models/", 
            "text": "Models\n\n\nCriando Models\n\n\nO \nProtonType\n usa o \nORM Sequelize\n para cria\u00e7\u00e3o dos Models e acesso ao banco de dados.\n\n\nPara criar um Model, deve-se criar uma classe que \nextends\n de \nBaseModel\n. O\nmapeamento do banco de dados \u00e9 feita a atrav\u00e9s da anota\u00e7\u00e3o @Model que possui os\nseguntes par\u00e2metros:\n\n\n\n\nname\n: Nome do model\n\n\ndefinition\n: Defini\u00e7\u00e3o das colunas. O objeto usado para as defini\u00e7\u00f5es \u00e9 o mesmo de\n    \ndefini\u00e7\u00e3o do\n    Sequelize\n.\n\n\n\n\nExemplo:\n\n\nimport\n \n{\n \nModelNames\n \n}\n \nfrom\n \n./ModelNames\n;\n\n\nimport\n \n{\n \nBaseModel\n,\n \nBelongsTo\n,\n \nDataTypes\n,\n \nModel\n,\n \nSequelizeBaseModelAttr\n \n}\n \nfrom\n \nprotontype\n;\n\n\n\n@\nModel\n({\n\n    \nname\n:\n \nModelNames\n.\nTASKS\n,\n\n    \ndefinition\n:\n \n{\n\n        \ntitle\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nSTRING\n,\n\n            \nallowNull\n:\n \nfalse\n,\n\n            \nvalidate\n:\n \n{\n\n                \nnotEmpty\n:\n \ntrue\n\n            \n}\n\n        \n},\n\n        \ndone\n:\n \n{\n\n            \ntype\n:\n \nDataTypes\n.\nBOOLEAN\n,\n\n            \nallowNull\n:\n \nfalse\n,\n\n            \ndefaultValue\n:\n \nfalse\n\n        \n}\n\n    \n}\n\n\n})\n\n\nexport\n \nclass\n \nTasksModel\n \nextends\n \nBaseModel\nTask\n \n{\n\n\n\n}\n\n\n\nexport\n \ninterface\n \nTask\n \nextends\n \nSequelizeBaseModelAttr\n \n{\n\n    \ntitle\n:\n \nstring\n;\n\n    \ndone\n:\n \nboolean\n;\n\n    \nuser_id\n:\n \nnumber\n;\n\n\n}\n\n\n\n\n\n\nCarregamento dos Models\n\n\nCada \nBaseModel\n ser\u00e1 carregado automaticamente na hora da sua instancia\u00e7\u00e3o. Geralmente o model sera carregado quando for usado por um \nRouter\n, por\u00e9m o carregamento poder\u00e1 ser for\u00e7ado atrav\u00e9s o \n@LoadModel\n decorator ou simplemente atrav\u00e9s do \nnew\n  \n\n\n@\nLoadModel\n(\nnew\n \nTaskModel\n())\n\n\nexport\n \nclass\n \nUsersModel\n \nextends\n \nBaseModel\nUser\n \n{\n\n\n\n}\n\n\n\n\n\n\nAdicionando relacionamentos e outras configura\u00e7\u00f5es nos Models\n\n\nUm BaseModel permite sobreescrever o m\u00e9todo \nconfigure()\n, que permite acessar a instancia do modelo Sequelize e os modelos j\u00e1 carregados e adicionar l\u00f3gicas e configura\u00e7\u00f5es:\n\n\nexport\n \nclass\n \nUsersModel\n \nextends\n \nBaseModel\nUser\n \n{\n\n    \npublic\n \nconfigure\n()\n:\n \nvoid\n \n{\n\n        \nthis\n.\ngetInstance\n().\nbeforeCreate\n((\nuser\n:\n \nany\n)\n \n=\n \n{\n\n            \nlet\n \nsalt\n:\n \nstring\n \n=\n \nbcrypt\n.\ngenSaltSync\n();\n\n            \nuser\n.\npassword\n \n=\n \nbcrypt\n.\nhashSync\n(\nuser\n.\npassword\n,\n \nsalt\n);\n\n        \n});\n\n\n        \nthis\n.\ngetInstance\n().\nhasMany\n(\nthis\n.\nProtonDB\n.\ngetModel\n(\nTasks\n).\ngetInstance\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsando decorators para criar relacionamentos\n\n\nAlguns decorators est\u00e3os dispon\u00edveis para facilitar a adi\u00e7\u00e3o dos relacionamentos:\n\n\n@\nHasMany\n(\nmodelName\n:\n \nstring\n)\n\n\n@\nHasOne\n(\nmodelName\n:\n \nstring\n)\n\n\n@\nBelongsTo\n(\nmodelName\n:\n \nstring\n)\n\n\n@\nBelongsToMany\n(\nmodelName\n:\n \nstring\n,\n \noptions\n:\n \nSequelize\n.\nAssociationOptionsBelongsToMany\n)\n\n\n\n\n\n\nEstes podem ser usados como nos exemplos abaixo:\n\n\n@\nHasMany\n(\nModelNames\n.\nTASKS\n)\n\n\nexport\n \nclass\n \nUsersModel\n \nextends\n \nBaseModel\nUser\n \n{\n\n    \npublic\n \nconfigure\n()\n:\n \nvoid\n \n{\n\n        \nthis\n.\ngetInstance\n().\nbeforeCreate\n((\nuser\n:\n \nany\n)\n \n=\n \n{\n\n            \nlet\n \nsalt\n:\n \nstring\n \n=\n \nbcrypt\n.\ngenSaltSync\n();\n\n            \nuser\n.\npassword\n \n=\n \nbcrypt\n.\nhashSync\n(\nuser\n.\npassword\n,\n \nsalt\n);\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\n@\nBelongsTo\n(\nModelNames\n.\nUSERS\n)\n\n\nexport\n \nclass\n \nTasksModel\n \nextends\n \nBaseModel\nTask\n \n{\n\n\n}\n\n\n\n\n\n\nPara mais informa\u00e7\u00f5es sobre as possibilidades de configura\u00e7\u00f5es e uso dos Models, consultar a documenta\u00e7\u00e3o do Sequelize: \nhttp://docs.sequelizejs.com/en/v3/", 
            "title": "Models"
        }, 
        {
            "location": "/models/#models", 
            "text": "", 
            "title": "Models"
        }, 
        {
            "location": "/models/#criando-models", 
            "text": "O  ProtonType  usa o  ORM Sequelize  para cria\u00e7\u00e3o dos Models e acesso ao banco de dados.  Para criar um Model, deve-se criar uma classe que  extends  de  BaseModel . O\nmapeamento do banco de dados \u00e9 feita a atrav\u00e9s da anota\u00e7\u00e3o @Model que possui os\nseguntes par\u00e2metros:   name : Nome do model  definition : Defini\u00e7\u00e3o das colunas. O objeto usado para as defini\u00e7\u00f5es \u00e9 o mesmo de\n     defini\u00e7\u00e3o do\n    Sequelize .   Exemplo:  import   {   ModelNames   }   from   ./ModelNames ;  import   {   BaseModel ,   BelongsTo ,   DataTypes ,   Model ,   SequelizeBaseModelAttr   }   from   protontype ;  @ Model ({ \n     name :   ModelNames . TASKS , \n     definition :   { \n         title :   { \n             type :   DataTypes . STRING , \n             allowNull :   false , \n             validate :   { \n                 notEmpty :   true \n             } \n         }, \n         done :   { \n             type :   DataTypes . BOOLEAN , \n             allowNull :   false , \n             defaultValue :   false \n         } \n     }  })  export   class   TasksModel   extends   BaseModel Task   {  }  export   interface   Task   extends   SequelizeBaseModelAttr   { \n     title :   string ; \n     done :   boolean ; \n     user_id :   number ;  }", 
            "title": "Criando Models"
        }, 
        {
            "location": "/models/#carregamento-dos-models", 
            "text": "Cada  BaseModel  ser\u00e1 carregado automaticamente na hora da sua instancia\u00e7\u00e3o. Geralmente o model sera carregado quando for usado por um  Router , por\u00e9m o carregamento poder\u00e1 ser for\u00e7ado atrav\u00e9s o  @LoadModel  decorator ou simplemente atrav\u00e9s do  new     @ LoadModel ( new   TaskModel ())  export   class   UsersModel   extends   BaseModel User   {  }", 
            "title": "Carregamento dos Models"
        }, 
        {
            "location": "/models/#adicionando-relacionamentos-e-outras-configuracoes-nos-models", 
            "text": "Um BaseModel permite sobreescrever o m\u00e9todo  configure() , que permite acessar a instancia do modelo Sequelize e os modelos j\u00e1 carregados e adicionar l\u00f3gicas e configura\u00e7\u00f5es:  export   class   UsersModel   extends   BaseModel User   { \n     public   configure () :   void   { \n         this . getInstance (). beforeCreate (( user :   any )   =   { \n             let   salt :   string   =   bcrypt . genSaltSync (); \n             user . password   =   bcrypt . hashSync ( user . password ,   salt ); \n         }); \n\n         this . getInstance (). hasMany ( this . ProtonDB . getModel ( Tasks ). getInstance ()); \n     }  }", 
            "title": "Adicionando relacionamentos e outras configura\u00e7\u00f5es nos Models"
        }, 
        {
            "location": "/models/#usando-decorators-para-criar-relacionamentos", 
            "text": "Alguns decorators est\u00e3os dispon\u00edveis para facilitar a adi\u00e7\u00e3o dos relacionamentos:  @ HasMany ( modelName :   string )  @ HasOne ( modelName :   string )  @ BelongsTo ( modelName :   string )  @ BelongsToMany ( modelName :   string ,   options :   Sequelize . AssociationOptionsBelongsToMany )   Estes podem ser usados como nos exemplos abaixo:  @ HasMany ( ModelNames . TASKS )  export   class   UsersModel   extends   BaseModel User   { \n     public   configure () :   void   { \n         this . getInstance (). beforeCreate (( user :   any )   =   { \n             let   salt :   string   =   bcrypt . genSaltSync (); \n             user . password   =   bcrypt . hashSync ( user . password ,   salt ); \n         }); \n     }  }   @ BelongsTo ( ModelNames . USERS )  export   class   TasksModel   extends   BaseModel Task   {  }   Para mais informa\u00e7\u00f5es sobre as possibilidades de configura\u00e7\u00f5es e uso dos Models, consultar a documenta\u00e7\u00e3o do Sequelize:  http://docs.sequelizejs.com/en/v3/", 
            "title": "Usando decorators para criar relacionamentos"
        }, 
        {
            "location": "/config/", 
            "text": "Configura\u00e7\u00f5es\n\n\nConfigura\u00e7\u00e3o do projeto TypeScript\n\n\nAs seguintes configura\u00e7\u00f5es no \ntsconfig.json\n s\u00e3o necess\u00e1rias para o\nfuncionamento.\n\n\n{\n\n    \ncompilerOptions\n:\n \n{\n\n    \ntarget\n:\n \nes5\n,\n\n    \nmodule\n:\n \ncommonjs\n,\n\n    \nemitDecoratorMetadata\n:\n \ntrue\n,\n\n    \nexperimentalDecorators\n:\n \ntrue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nConfigura\u00e7\u00f5es da Aplica\u00e7\u00e3o\n\n\nPor padr\u00e3o a aplica\u00e7\u00e3o procurar\u00e1 um arquivo \nproton.json\n que poder\u00e1 ter as configura\u00e7\u00f5es: \n\n\n{\n\n  \nport\n:\n \n3000\n,\n\n  \ndefaultRoutes\n:\n \ntrue\n,\n\n  \ndatabase\n:\n \n{\n\n    \nname\n:\n \nproton-example\n,\n\n    \nusername\n:\n \n,\n\n    \npassword\n:\n \n,\n\n    \noptions\n:\n \n{\n\n      \ndialect\n:\n \nsqlite\n,\n\n      \nstorage\n:\n \n./src/test/proton.sqlite\n,\n\n      \ndefine\n:\n \n{\n\n        \nunderscored\n:\n \ntrue\n\n      \n},\n\n      \nlogging\n:\n \nfalse\n\n    \n}\n\n  \n},\n\n  \ncors\n:\n \n{\n\n    \norigin\n:\n \n*\n,\n\n    \nmethods\n:\n \n[\nGET\n,\n \nPOST\n,\n \nOPTIONS\n,\n \nPUT\n,\n \nPATCH\n,\n \nDELETE\n],\n\n    \nallowedHeaders\n:\n \n[\nContent-Type\n,\n \nAuthorization\n]\n\n  \n},\n\n  \nlogger\n:\n \n{\n\n    \nenabled\n:\n \nfalse\n,\n\n    \ntransports\n:\n \n[\n\n      \n{\n\n        \ntype\n:\n \nfile\n,\n\n        \noptions\n:\n \n{\n\n          \nfilename\n:\n \n./test/logs.log\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \ntype\n:\n \nconsole\n\n      \n}\n\n    \n]\n\n  \n},\n\n  \nhttps\n:\n \n{\n\n    \nenabled\n:\n \nfalse\n,\n\n    \nkey\n:\n \n./src/cert/cert.key\n,\n\n    \ncert\n:\n \n./src/cert/cert.cert\n\n  \n}\n\n\n}\n\n\n\n\n\n\nEstrutura do Arquivo de Configura\u00e7\u00e3o\n\n\nexport\n \ninterface\n \nGlobalConfig\n \n{\n\n    \nport\n:\n \nnumber\n;\n\n    \ndatabase\n:\n \nDatabaseConfig\n;\n\n    \ncors\n?:\n \ncors\n.\nCorsOptions\n;\n\n    \nlogger\n?:\n \nLoggerConfig\n;\n\n    \nhttps\n?:\n \nHTTPSConfig\n;\n\n    \ndefaultRoutes\n?:\n \nboolean\n;\n\n\n}\n\n\nexport\n \ninterface\n \nDatabaseConfig\n \n{\n\n    \nname\n:\n \nstring\n;\n\n    \nusername\n:\n \nstring\n;\n\n    \npassword\n:\n \nstring\n;\n\n    \noptions\n:\n \nsequelize\n.\nOptions\n;\n\n\n}\n\n\nexport\n \ninterface\n \nDBDefine\n \n{\n\n    \nunderscored\n:\n \nboolean\n;\n\n\n}\n\n\nexport\n \ninterface\n \nHTTPSConfig\n \n{\n\n    \nenabled\n:\n \nboolean\n;\n\n    \nkey\n:\n \nstring\n;\n\n    \ncert\n:\n \nstring\n;\n\n\n}\n\n\nexport\n \ninterface\n \nLoggerConfig\n \n{\n\n    \nenabled\n:\n \nboolean\n;\n\n    \ntransports\n:\n \n{\n\n        \ntype\n:\n \nstring\n;\n\n        \noptions\n:\n \nwinston\n.\nTransportOptions\n;\n\n    \n}[];\n\n\n}\n\n\n\n\n\n\nGlobalConfig\n\n\n\n\n\n\n\n\nProriedade\n\n\nTipo\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\nport\n\n\nnumber\n\n\nPorta em que a aplica\u00e7\u00e3o ir\u00e1 levantar\n\n\n\n\n\n\ndatabase\n\n\nDatabaseConfig\n\n\nConfigura\u00e7\u00e3o da base de dados usada pela aplica\u00e7\u00e3o\n\n\n\n\n\n\ncors\n\n\ncors.CorsOptions\n\n\nConfigura\u00e7\u00e3o do CORS da aplica\u00e7\u00e3o. O Protontype usa o m\u00f3dulo \ncors\n para fazer esse trabalho. Esta propriedade segue o mesmo \nobjeto de configura\u00e7\u00e3o do m\u00f3dulo cors\n\n\n\n\n\n\nlogger\n\n\nLoggerConfig\n\n\nConfigura\u00e7\u00f5es de log\n\n\n\n\n\n\nhttps\n\n\nHTTPSConfig\n\n\nHabilita e configura o HTTPS na aplica\u00e7\u00e3o\n\n\n\n\n\n\ndefaultRoutes\n\n\nboolean\n\n\nHabilita a configura\u00e7\u00e3o das rotas par\u00f5es que a aplica\u00e7\u00e3o disponibiliza.\n\n\n\n\n\n\n\n\nDatabaseConfig\n\n\n\n\n\n\n\n\nPropriedade\n\n\nTipo\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nNome do banco de dados\n\n\n\n\n\n\nusername\n\n\nstring\n\n\nUsername para conex\u00e3o com banco de dados\n\n\n\n\n\n\npassword\n\n\nstring\n\n\nSenha para conex\u00e3o com o banco de dados\n\n\n\n\n\n\noptions\n\n\nsequelize.Options\n\n\nOp\u00e7\u00f5es de configura\u00e7\u00e3o do Sequelize\n.\n\n\n\n\n\n\n\n\nsequelize.Options\n\n\n\n\n\n\n\n\nPropriedade\n\n\nTipo\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\ndialect\n\n\nstring\n\n\nDialeto do banco de dados. Podem ser: mysql, postgres, sqlite, mariadb ou mssql.\n\n\n\n\n\n\nstorage\n\n\nstring\n\n\nSomente usado para sqlite. Local do aquivo usado para o banco de dados\n\n\n\n\n\n\n\n\nLoggerConfig\n\n\n\n\n\n\n\n\nPropriedade\n\n\nTipo\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nHabilita o log\n\n\n\n\n\n\ntransports\n\n\nObject\n\n\nConfigura onde os logs ser\u00e3o exibidos ou gravados\n\n\n\n\n\n\n\n\ntransports\n\n\n\n\n\n\n\n\nPropriedade\n\n\nTipo\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nstring\n\n\nPode ser: \"file\" ou \"console\"\n\n\n\n\n\n\noptions\n\n\nwinston.TransportOptions\n\n\nOp\u00e7\u00f5es do m\u00f3dulo \nWinston\n\n\n\n\n\n\n\n\nExemplo\n\n\ntransports\n:\n \n[\n\n      \n{\n\n        \ntype\n:\n \nfile\n,\n\n        \noptions\n:\n \n{\n\n          \nfilename\n:\n \n./test/logs.log\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \ntype\n:\n \nconsole\n\n      \n}\n\n    \n]\n\n  \n}\n\n\n\n\n\n\nHTTPSConfig\n\n\n\n\n\n\n\n\nPropriedade\n\n\nTipo\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nHabilita o HTTPS\n\n\n\n\n\n\nkey\n\n\nstring\n\n\nChave privada do certificado\n\n\n\n\n\n\ncert\n\n\nstring\n\n\nArquivo que cont\u00e9m o certificado (chave p\u00fablica)", 
            "title": "Configura\u00e7\u00f5es"
        }, 
        {
            "location": "/config/#configuracoes", 
            "text": "", 
            "title": "Configura\u00e7\u00f5es"
        }, 
        {
            "location": "/config/#configuracao-do-projeto-typescript", 
            "text": "As seguintes configura\u00e7\u00f5es no  tsconfig.json  s\u00e3o necess\u00e1rias para o\nfuncionamento.  { \n     compilerOptions :   { \n     target :   es5 , \n     module :   commonjs , \n     emitDecoratorMetadata :   true , \n     experimentalDecorators :   true \n     }  }", 
            "title": "Configura\u00e7\u00e3o do projeto TypeScript"
        }, 
        {
            "location": "/config/#configuracoes-da-aplicacao", 
            "text": "Por padr\u00e3o a aplica\u00e7\u00e3o procurar\u00e1 um arquivo  proton.json  que poder\u00e1 ter as configura\u00e7\u00f5es:   { \n   port :   3000 , \n   defaultRoutes :   true , \n   database :   { \n     name :   proton-example , \n     username :   , \n     password :   , \n     options :   { \n       dialect :   sqlite , \n       storage :   ./src/test/proton.sqlite , \n       define :   { \n         underscored :   true \n       }, \n       logging :   false \n     } \n   }, \n   cors :   { \n     origin :   * , \n     methods :   [ GET ,   POST ,   OPTIONS ,   PUT ,   PATCH ,   DELETE ], \n     allowedHeaders :   [ Content-Type ,   Authorization ] \n   }, \n   logger :   { \n     enabled :   false , \n     transports :   [ \n       { \n         type :   file , \n         options :   { \n           filename :   ./test/logs.log \n         } \n       }, \n       { \n         type :   console \n       } \n     ] \n   }, \n   https :   { \n     enabled :   false , \n     key :   ./src/cert/cert.key , \n     cert :   ./src/cert/cert.cert \n   }  }", 
            "title": "Configura\u00e7\u00f5es da Aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/config/#estrutura-do-arquivo-de-configuracao", 
            "text": "export   interface   GlobalConfig   { \n     port :   number ; \n     database :   DatabaseConfig ; \n     cors ?:   cors . CorsOptions ; \n     logger ?:   LoggerConfig ; \n     https ?:   HTTPSConfig ; \n     defaultRoutes ?:   boolean ;  }  export   interface   DatabaseConfig   { \n     name :   string ; \n     username :   string ; \n     password :   string ; \n     options :   sequelize . Options ;  }  export   interface   DBDefine   { \n     underscored :   boolean ;  }  export   interface   HTTPSConfig   { \n     enabled :   boolean ; \n     key :   string ; \n     cert :   string ;  }  export   interface   LoggerConfig   { \n     enabled :   boolean ; \n     transports :   { \n         type :   string ; \n         options :   winston . TransportOptions ; \n     }[];  }", 
            "title": "Estrutura do Arquivo de Configura\u00e7\u00e3o"
        }, 
        {
            "location": "/config/#globalconfig", 
            "text": "Proriedade  Tipo  Descri\u00e7\u00e3o      port  number  Porta em que a aplica\u00e7\u00e3o ir\u00e1 levantar    database  DatabaseConfig  Configura\u00e7\u00e3o da base de dados usada pela aplica\u00e7\u00e3o    cors  cors.CorsOptions  Configura\u00e7\u00e3o do CORS da aplica\u00e7\u00e3o. O Protontype usa o m\u00f3dulo  cors  para fazer esse trabalho. Esta propriedade segue o mesmo  objeto de configura\u00e7\u00e3o do m\u00f3dulo cors    logger  LoggerConfig  Configura\u00e7\u00f5es de log    https  HTTPSConfig  Habilita e configura o HTTPS na aplica\u00e7\u00e3o    defaultRoutes  boolean  Habilita a configura\u00e7\u00e3o das rotas par\u00f5es que a aplica\u00e7\u00e3o disponibiliza.", 
            "title": "GlobalConfig"
        }, 
        {
            "location": "/config/#databaseconfig", 
            "text": "Propriedade  Tipo  Descri\u00e7\u00e3o      name  string  Nome do banco de dados    username  string  Username para conex\u00e3o com banco de dados    password  string  Senha para conex\u00e3o com o banco de dados    options  sequelize.Options  Op\u00e7\u00f5es de configura\u00e7\u00e3o do Sequelize .", 
            "title": "DatabaseConfig"
        }, 
        {
            "location": "/config/#sequelizeoptions", 
            "text": "Propriedade  Tipo  Descri\u00e7\u00e3o      dialect  string  Dialeto do banco de dados. Podem ser: mysql, postgres, sqlite, mariadb ou mssql.    storage  string  Somente usado para sqlite. Local do aquivo usado para o banco de dados", 
            "title": "sequelize.Options"
        }, 
        {
            "location": "/config/#loggerconfig", 
            "text": "Propriedade  Tipo  Descri\u00e7\u00e3o      enabled  boolean  Habilita o log    transports  Object  Configura onde os logs ser\u00e3o exibidos ou gravados", 
            "title": "LoggerConfig"
        }, 
        {
            "location": "/config/#transports", 
            "text": "Propriedade  Tipo  Descri\u00e7\u00e3o      type  string  Pode ser: \"file\" ou \"console\"    options  winston.TransportOptions  Op\u00e7\u00f5es do m\u00f3dulo  Winston     Exemplo  transports :   [ \n       { \n         type :   file , \n         options :   { \n           filename :   ./test/logs.log \n         } \n       }, \n       { \n         type :   console \n       } \n     ] \n   }", 
            "title": "transports"
        }, 
        {
            "location": "/config/#httpsconfig", 
            "text": "Propriedade  Tipo  Descri\u00e7\u00e3o      enabled  boolean  Habilita o HTTPS    key  string  Chave privada do certificado    cert  string  Arquivo que cont\u00e9m o certificado (chave p\u00fablica)", 
            "title": "HTTPSConfig"
        }, 
        {
            "location": "/bootstrap/", 
            "text": "Iniciando aplica\u00e7\u00e3o\n\n\nlet\n \nexpressApp\n \n=\n \nnew\n \nProtonApplication\n();\n\n\nexpressApp\n\n    \n.\nwithAuthMiddleware\n(\nnew\n \nJWTAuthMiddleware\n())\n\n    \n.\naddRouter\n(\nnew\n \nTasksRouter\n())\n\n    \n.\naddMiddleware\n(\nnew\n \nTasksMiddleware\n())\n\n    \n.\nbootstrap\n();\n\n\n\n\n\n\nConfigura\u00e7\u00f5es do bootstrap\n\n\nMiddlewares\n\n\nPara adicionar um middleware a aplica\u00e7\u00e3o. Este middleware afetar\u00e1 todas as rotas da aplica\u00e7\u00e3o\n\n\nexpressApp\n.\naddMiddleware\n(\nnew\n \nTasksMiddleware\n());\n\n\n\n\n\n\nMiddleware de Autentica\u00e7\u00e3o\n\n\nPara adicionar um middleware respons\u00e1vel para fazer a autentica\u00e7\u00e3o. Este middleware afetar\u00e1:\n\n\n\n\nTodos Routers anotadas com o decorator \n@UseAuth()\n\n\nTodas rotas dentro de um router que possua o par\u00e2metro \nuseAuth: true\n do decotarot \n@Route()\n\n\n\n\nexpressApp\n.\nwithAuthMiddleware\n(\nnew\n \nJWTAuthMiddleware\n());\n\n\n\n\n\n\nRouters\n\n\nAdiciona um Router para que a apica\u00e7\u00e3o configure e levante suas rotas\n\n\nexpressApp\n.\naddRouter\n(\nnew\n \nTasksRouter\n());\n\n\n\n\n\n\nBootstrap\n\n\nO m\u00e9todo \nexpressApp.bootstrap()\n inicia a aplica\u00e7\u00e3o, suas rotas e middlewares configurados.\n\n\nExemplo de uso completo\n\n\nhttps://github.com/linck/protontype-example", 
            "title": "Iniciando Aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/bootstrap/#iniciando-aplicacao", 
            "text": "let   expressApp   =   new   ProtonApplication ();  expressApp \n     . withAuthMiddleware ( new   JWTAuthMiddleware ()) \n     . addRouter ( new   TasksRouter ()) \n     . addMiddleware ( new   TasksMiddleware ()) \n     . bootstrap ();", 
            "title": "Iniciando aplica\u00e7\u00e3o"
        }, 
        {
            "location": "/bootstrap/#configuracoes-do-bootstrap", 
            "text": "", 
            "title": "Configura\u00e7\u00f5es do bootstrap"
        }, 
        {
            "location": "/bootstrap/#middlewares", 
            "text": "Para adicionar um middleware a aplica\u00e7\u00e3o. Este middleware afetar\u00e1 todas as rotas da aplica\u00e7\u00e3o  expressApp . addMiddleware ( new   TasksMiddleware ());", 
            "title": "Middlewares"
        }, 
        {
            "location": "/bootstrap/#middleware-de-autenticacao", 
            "text": "Para adicionar um middleware respons\u00e1vel para fazer a autentica\u00e7\u00e3o. Este middleware afetar\u00e1:   Todos Routers anotadas com o decorator  @UseAuth()  Todas rotas dentro de um router que possua o par\u00e2metro  useAuth: true  do decotarot  @Route()   expressApp . withAuthMiddleware ( new   JWTAuthMiddleware ());", 
            "title": "Middleware de Autentica\u00e7\u00e3o"
        }, 
        {
            "location": "/bootstrap/#routers", 
            "text": "Adiciona um Router para que a apica\u00e7\u00e3o configure e levante suas rotas  expressApp . addRouter ( new   TasksRouter ());", 
            "title": "Routers"
        }, 
        {
            "location": "/bootstrap/#bootstrap", 
            "text": "O m\u00e9todo  expressApp.bootstrap()  inicia a aplica\u00e7\u00e3o, suas rotas e middlewares configurados.", 
            "title": "Bootstrap"
        }, 
        {
            "location": "/bootstrap/#exemplo-de-uso-completo", 
            "text": "https://github.com/linck/protontype-example", 
            "title": "Exemplo de uso completo"
        }, 
        {
            "location": "/license/", 
            "text": "The MIT License\n\n\nCopyright (c) 2017 Humberto Machado\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.", 
            "title": "License"
        }
    ]
}